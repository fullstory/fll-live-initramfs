#!/bin/sh
#
# F.U.L.L.S.T.O.R.Y initramfs live media mount script
#
# Copyright: (C) 2025, Kel Modderman <kelvmod@gmail.com>
# License:   GPLv2
#
# F.U.L.L.S.T.O.R.Y Project Homepage:
# https://github.com/fullstory
#
# This script:
#  * inspects a block device/partition for the UUID of the carrier
#    filesystem (iso9660) containing the readonly rootfs images
#  * mounts readonly rootfs and sets up COW/tmpfs overlay
#  * creates a symlink to the readonly rootfs image for use by calamares
#  * create udev rule for persistent symlink to device live media was found on
#  * updates live username variable if given on boot cmdline
#  * configures live hostname, timezone, and getty

copy_with_perc()
{
    # background the copy, grab the process id
    dd if="${1}" of="${2}" bs=1M status=none &

    # calculate copying progress
    awk -v pid="${!}" -v ifile="${1}" -v ofile="${2}" '
        function get_size(path)
        {
            if (system("test -b " path) == 0)
                return get_blockdev_size(path)
            else
                return get_file_size(path)
        }

        function get_file_size(file)
        {
            size = 0
            cmd = "ls -l " file
            if ((cmd | getline) > 0)
                size = int($5)
            close(cmd)
            return size
        }

        function get_blockdev_size(dev)
        {
            size = 0
            cmd = "blockdev --getsize64 " dev
            if ((cmd | getline) > 0)
                size = int($1)
            close(cmd)
            return size
        }

        function get_fd(pid, file)
        {
            fd = -1
            cmd = "ls -l /proc/" pid "/fd/"
            while ((cmd | getline) > 0) {
                if ($NF == file) {
                    fd = $9
                    break
                }
            }
            close(cmd)
            return fd
        }

        function get_pos(pid, fd)
        {
            pos = -1
            cmd = "cat /proc/" pid "/fdinfo/" fd " 2>/dev/null"
            while ((cmd | getline) > 0) {
                if (/pos:/) {
                    pos = $2
                    break
                }
            }
            close(cmd)
            return pos
        }

        BEGIN {
            perc = 0
            ifile_size = get_size(ifile)
            if (ifile_size <= 0) {
                printf("\ntoram failed: %s\n", ifile)
                exit(1)
            }

            printf("\ntoram: %s -> %s\n", ifile, ofile)

            do {
                ifile_fd = get_fd(pid, ifile)
                ifile_pos = get_pos(pid, ifile_fd)
                perc = int(100 * ifile_pos / ifile_size)
                if (perc > 0 && perc < 100) {
                    printf("\r[")
                    for (i = 0; i <= perc; i += 2)
                        printf("=")
                    printf(">")
                    for (i = perc; i < 100; i += 2)
                        printf(" ")
                    printf("]  ")
                    printf("%02d%s", perc, "%")
                }
            } while (system("sleep 1") == 0 &&
                     system("test -d /proc/" pid "/fd") == 0)

            # ofile size is > if size on tmpfs
            if (get_size(ofile) >= ifile_size) {
                printf("\r[")
                for (i = 0; i <= 100; i += 2)
                    printf("=")
                printf("=] ")
                printf("%s\n", "100%")
                exit(0)
            }
            else {
                printf("\ntoram failed: %s\n", ifile)
                exit(1)
            }
        }'
    return ${?}
}

if grep -qw 'fll=debug' /proc/cmdline; then
    set -x
    env
fi

[ -n "${ID_FS_TYPE}" ] || ID_FS_TYPE="$(blkid -s TYPE -o value ${DEVNAME})"

case "${ID_FS_TYPE}" in
    iso9660|ext*|btrfs|jfs|f2fs|xfs|ntfs|vfat|exfat|udf|erofs|squashfs)
        :
        ;;
    *)
        exit 1
        ;;
esac

[ -n "${ID_FS_UUID}" ] || ID_FS_UUID="$(blkid -s UUID -o value ${DEVNAME})"

# source distro-defaults
[ -s /etc/default/distro ] && . /etc/default/distro

FLL_CHECKSUM_CHECK="no"
FLL_COPY_TORAM="no"
FLL_ISO_UUID=""
FLL_ROOTFS_UUID=""
FLL_PERSIST_UUID=""

# parse fll options given on cmdline
for opt in $(cat /proc/cmdline); do
    case "${opt}" in
        fromiso=*)
            FLL_MEDIA_NAME="${opt#fromiso=}"
            ;;
        fromhd=*)
            # support for grub2-fll-fromiso: if fromhd=UUID= or
            # fromhd=/dev/disk/by-uuid/ or is provided then only accept block
            # devices with matching ID_FS_UUID.
            FLL_FROMHD="${opt#fromhd=}"
            case "${FLL_FROMHD}" in
                UUID=*)
                    [ "${FLL_FROMHD#UUID=}" = "${ID_FS_UUID}" ] || exit 1
                    ;;
                /dev/disk/by-uuid/*)
                    [ "${FLL_FROMHD#/dev/disk/by-uuid/}" = "${ID_FS_UUID}" ] || exit 1
                    ;;
                /dev/*)
                    [ "$(readlink -f ${FLL_FROMHD})" = "${DEVNAME}" ] || exit 1
                    ;;
            esac
            ;;
        hostname=*)
            CUSTOM_HOSTNAME="${opt#hostname=}"
            ;;
        image_dir=*)
            FLL_IMAGE_DIR="${opt#image_dir=}"
            FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
            ;;
        image_name=*)
            FLL_IMAGE_FILE="${opt#image_name=}"
            FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
            ;;
        iso_uuid=*)
            FLL_ISO_UUID="${opt#iso_uuid=}"
            ;;
        persist_uuid=*)
            FLL_PERSIST_UUID="${opt#persist_uuid=}"
            ;;
        rootfs_uuid=*)
            FLL_ROOTFS_UUID="${opt#rootfs_uuid=}"
            # only accept partitions when rootfs_uuid is given
            [ "${DEVTYPE}" = "partition" ] || exit 1
            ;;
        sha256sum|sha256sums|checksum|checksums)
            FLL_CHECKSUM_CHECK="yes"
            ;;
        toram)
            FLL_COPY_TORAM="yes"
            ;;
        tz=*)
            CUSTOM_TZ="${opt#tz=}"
            ;;
        username=*)
            FLL_LIVE_USER="${opt#username=}"
            ;;
        utc=yes)
            UTC="yes"
            ;;
        utc|gmt)
            CUSTOM_TZ="Etc/UTC"
            ;;
    esac
done

FLL_ROOTFS_MNT="${rootmnt:-/root}"
FLL_ISOMEDIA_MNT=""
FLL_READONLY_MNT=""
FLL_READONLY_FILE=""
FLL_READONLY_FSTYPE=""
FLL_BLOCKDEV_MNT=""
# rootfs_uuid matches block device uuid => accessing GPT partition directly
if [ "${ID_FS_UUID}" = "${FLL_ROOTFS_UUID}" ]; then
    FLL_READONLY_MNT="/fll/${FLL_ROOTFS_UUID}"
    FLL_READONLY_FILE="${DEVNAME}"
    FLL_READONLY_FSTYPE="${ID_FS_TYPE}"

    # toram support
    if [ "${FLL_COPY_TORAM}" = "yes" ]; then
        mkdir -p /fll/toram
        if mount -n -t tmpfs -o size=90% tmpfs /fll/toram; then
            mkdir /fll/toram/"${FLL_IMAGE_DIR}"
            if copy_with_perc "${FLL_READONLY_FILE}" /fll/toram/"${FLL_IMAGE_LOCATION}"; then
                FLL_READONLY_FILE=/fll/toram/"${FLL_IMAGE_LOCATION}"
            else
                umount /fll/toram
                rmdir /fll/toram
            fi
        else
            rmdir /fll/toram
        fi
    fi
else
    FLL_READONLY_MNT="/fll/${FLL_ISO_UUID}"
    FLL_BLOCKDEV_MNT="/fll/${DEVNAME#/dev/}"
    mkdir -p "${FLL_BLOCKDEV_MNT}"
    mount -t "${ID_FS_TYPE}" -o ro "${DEVNAME}" "${FLL_BLOCKDEV_MNT}"

    # iso9660 filesystem on block device (cd/dvd/usb)
    if [ "${ID_FS_UUID}" = "${FLL_ISO_UUID}" ] && [ -f "${FLL_BLOCKDEV_MNT}/${FLL_IMAGE_LOCATION}" ]; then
        FLL_ISOMEDIA_MNT="${FLL_BLOCKDEV_MNT}"
    # iso file on filesystem (fromiso=)
    elif [ -f "${FLL_BLOCKDEV_MNT}/${FLL_MEDIA_NAME#/}" ] && \
        [ "$(blkid -s UUID -o value ${FLL_BLOCKDEV_MNT}/${FLL_MEDIA_NAME#/})" = "${FLL_ISO_UUID}" ]; then
        FLL_ISOMEDIA_MNT="/fll/fromiso"; mkdir -p "${FLL_ISOMEDIA_MNT}"
        mount -t iso9660 -o ro "${FLL_BLOCKDEV_MNT}/${FLL_MEDIA_NAME#/}" "${FLL_ISOMEDIA_MNT}"
    # no iso media detected by UUID
    else
        umount "${FLL_BLOCKDEV_MNT}"
        exit 1
    fi

    # check integrity of live media if requested
    if [ "${FLL_CHECKSUM_CHECK}" = "yes" ] && ! ( cd "${FLL_ISOMEDIA_MNT}" && sha256sum -c "sha256sums" ); then
        printf "ERROR: sha256sum check failed\n"
        exit 1
    fi

    # toram support
    if [ "${FLL_COPY_TORAM}" = "yes" ]; then
        mkdir -p /fll/toram
        if mount -n -t tmpfs -o size=90% tmpfs /fll/toram; then
            mkdir /fll/toram/"${FLL_IMAGE_DIR}"
            if copy_with_perc "${FLL_ISOMEDIA_MNT}/${FLL_IMAGE_LOCATION}" /fll/toram/"${FLL_IMAGE_LOCATION}"; then
                grep -qw "${FLL_ISOMEDIA_MNT}" /proc/mounts && umount -l "${FLL_ISOMEDIA_MNT}"
                grep -qw "${FLL_BLOCKDEV_MNT}" /proc/mounts && umount -l "${FLL_BLOCKDEV_MNT}"
                FLL_ISOMEDIA_MNT=/fll/toram
            else
                umount /fll/toram
                rmdir /fll/toram
            fi
        else
            rmdir /fll/toram
        fi
    fi

    FLL_READONLY_FILE="${FLL_ISOMEDIA_MNT}/${FLL_IMAGE_LOCATION}"
    FLL_READONLY_FSTYPE="$(blkid -s TYPE -o value ${FLL_READONLY_FILE})"
fi

# mount readonly rootfs
mkdir -p "${FLL_READONLY_MNT}"
if ! mount -t "${FLL_READONLY_FSTYPE}" -o ro "${FLL_READONLY_FILE}" "${FLL_READONLY_MNT}"; then
    exit 1
fi

# prepare COW/tmpfs union filesystem
FLL_UNION_MODULE="overlay"
FLL_UNION_COWDIR="/fll/cow"
FLL_UNION_OPTIONS="lowerdir=${FLL_READONLY_MNT},upperdir=${FLL_UNION_COWDIR}/upper,workdir=${FLL_UNION_COWDIR}/work"
modprobe "${FLL_UNION_MODULE}"
mkdir -p "${FLL_UNION_COWDIR}"
if [ "${FLL_PERSIST_UUID}" != "" ]; then
    # the persist partition will be on the same disk as rootfs, the secret sauce
    # to successfully mounting it is that we _must_ access the rootfs by partition,
    # and not via the disk devtype / iso9660 wrapper
    mount -n -o rw "/dev/disk/by-uuid/${FLL_PERSIST_UUID}" "${FLL_UNION_COWDIR}"
else
    mount -n -t tmpfs -o size=90%,mode=755 tmpfs "${FLL_UNION_COWDIR}"
fi
mkdir -p "${FLL_UNION_COWDIR}/upper" "${FLL_UNION_COWDIR}/work"
mount -t "${FLL_UNION_MODULE}" -o "${FLL_UNION_OPTIONS}" "${FLL_UNION_MODULE}" "${FLL_ROOTFS_MNT}"

# create /fll and migrate mountpoints
mkdir -p "${FLL_ROOTFS_MNT}/fll"
for mnt in ${FLL_READONLY_MNT} ${FLL_UNION_COWDIR} ${FLL_BLOCKDEV_MNT} ${FLL_ISOMEDIA_MNT}; do
    if grep -qw "${mnt}" /proc/mounts; then
        if [ ! -d "${FLL_ROOTFS_MNT}${mnt}" ]; then
            mkdir -p "${FLL_ROOTFS_MNT}${mnt}"
            mount -n -o move "${mnt}" "${FLL_ROOTFS_MNT}${mnt}"
        fi
    fi
done

# create symlink to readonly rootfs for calamares
ln -sf "${FLL_READONLY_FILE}" "${FLL_ROOTFS_MNT}/fll/${FLL_READONLY_FSTYPE}"

# update calamares unpackfs(c).conf with readonly fstype
if [ -d "${FLL_ROOTFS_MNT}/etc/calamares/modules" ]; then
    sed -i "s/FLL_READONLY_FSTYPE/${FLL_READONLY_FSTYPE}/" \
        "${FLL_ROOTFS_MNT}/etc/calamares/modules/unpackfs"*
fi

# prepare /dev /media /proc and /sys
for dir in dev media proc run sys; do
    mkdir -p -m 0755 "${FLL_ROOTFS_MNT}/${dir}"
done

# tmp with correct permissions for users
mkdir -p -m 1777 "${FLL_ROOTFS_MNT}/tmp"

# create udev rule for persistent symlink to device live media was found on
printf "KERNEL==\"%s\", SYMLINK+=\"fll\"\n" \
    "${DEVNAME#/dev/}" >  "${FLL_ROOTFS_MNT}"/etc/udev/rules.d/70-fll-live.rules
printf "KERNEL==\"%s\", ENV{ID_CDROM}==\"?*\", SYMLINK+=\"fll-cdrom\"\n" \
    "${DEVNAME#/dev/}" >> "${FLL_ROOTFS_MNT}"/etc/udev/rules.d/70-fll-live.rules

# Patch /etc/default/distro for custom username
sed -i "s#^FLL_LIVE_USER=.*#FLL_LIVE_USER=\"${FLL_LIVE_USER}\"#" \
    "${FLL_ROOTFS_MNT}/etc/default/distro"

# custom hostname given on cmdline
if [ "${CUSTOM_HOSTNAME}" ]; then
    echo "${CUSTOM_HOSTNAME}" > "${FLL_ROOTFS_MNT}/etc/hostname"
    echo "${CUSTOM_HOSTNAME}" > "${FLL_ROOTFS_MNT}/etc/mailname"
    # update /etc/hosts
    sed -i '/localhost/!s/^\(127.0.0.1[ \t]\+\)\(.\+\)$/\1'"${CUSTOM_HOSTNAME}"'/' \
        "${FLL_ROOTFS_MNT}/etc/hosts"
fi

# allow CUSTOM_TZ to override above TZ definitions
if [ -n "${CUSTOM_TZ}" ]; then
    case "${CUSTOM_TZ}" in
        utc|UTC)
            CUSTOM_TZ="Etc/UTC"
            ;;
    esac
    [ -f "${FLL_ROOTFS_MNT}/usr/share/zoneinfo/${CUSTOM_TZ}" ] && TZ="${CUSTOM_TZ}"
fi

# configure timezone, fallback to UTC
[ -f "${FLL_ROOTFS_MNT}/usr/share/zoneinfo/${TZ}" ] || TZ="Etc/UTC"
echo "${TZ}" > "${FLL_ROOTFS_MNT}/etc/timezone"
rm -f "${FLL_ROOTFS_MNT}/etc/localtime"
ln -sf "/usr/share/zoneinfo/${TZ}" "${FLL_ROOTFS_MNT}/etc/localtime"

# make localtime default, unless tz=Etc/UTC or utc=yes
if [ "${TZ}" = "Etc/UTC" ] || [ "${UTC}" = "yes" ]; then
    printf "0.000000 0 0.000000\n0\nUTC\n" > "${FLL_ROOTFS_MNT}/etc/adjtime"
else
    # debian defaults to UTC=yes, which is rumored to be dual-boot unfriendly
    printf "0.000000 0 0.000000\n0\nLOCAL\n" > "${FLL_ROOTFS_MNT}/etc/adjtime"
fi

# configure live getty configuration for systemd
if [ -r "${FLL_ROOTFS_MNT}/lib/systemd/system/getty@.service" ]; then
    sed -e 's#^ExecStart=.*#ExecStart=-/sbin/agetty --noclear -n -i -l /usr/bin/fll_login %I 38400 linux#' \
        "${FLL_ROOTFS_MNT}/lib/systemd/system/getty@.service" > \
        "${FLL_ROOTFS_MNT}/etc/systemd/system/getty@.service"
    ln -fs /etc/systemd/system/getty@.service \
        "${FLL_ROOTFS_MNT}/etc/systemd/system/getty.target.wants/getty@tty1.service"
    ln -fs getty@.service "${FLL_ROOTFS_MNT}/etc/systemd/system/autovt@.service"
fi

# success
exit 0
