#!/bin/sh

###############################################################################
#	F.U.L.L.S.T.O.R.Y initramfs live media init functions
#
#	Copyright:	(C) 2007 F.U.L.L.S.T.O.R.Y Project
#	License:	GPLv2
#
#	F.U.L.L.S.T.O.R.Y Project Homepage:
#	http://developer.berlios.de/projects/fullstory
###############################################################################
#	expand scope of PATH
###############################################################################
export PATH=/root/usr/bin:/root/usr/sbin:/root/bin:/root/sbin:/usr/bin:/usr/sbin:/bin:/sbin
###############################################################################
#	colourful escape sequences
###############################################################################
export NORMAL="[0;39m"	# NORMAL: Normal color
export BLUE="[1;34m"		# BLUE: System mesages
export RED="[1;31m"		# RED: Failure or error message
export GREEN="[1;32m"		# GREEN: Success message
export YELLOW="[1;33m"	# YELLOW: Descriptions
export WHITE="[1;37m"		# BOLD WHITE: Hint
###############################################################################
#	force our arch string for i386
###############################################################################
case "${DPKG_ARCH}" in
	i?86)
		FLL_ARCH="i686"
		;;
	*)
		FLL_ARCH="${DPKG_ARCH}"
		;;
esac
export FLL_ARCH
###############################################################################
# 	parse /proc/cmdline for fll specific options
###############################################################################
fll_parse_cmdline()
{
	for opt in $(cat /proc/cmdline); do
		case "${opt}" in
			fll=debug)
				set -x
				;;
			fromhd=*)
				FLL_BLOCKDEVS="${opt#fromhd=}"
				;;
			fromiso*)
				FLL_FROMISO="yes"
				;;
			image_dir=*)
				FLL_IMAGE_DIR="${opt#image_dir=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			image_name=*)
				FLL_IMAGE_FILE="${opt#image_name=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			iso_dir=*)
				FLL_MEDIA_DIR="${opt#iso_dir=}"
				;;
			iso_name=*)
				FLL_MEDIA_NAME="${opt#iso_name=}"
				;;
			toram)
				FLL_TORAM="yes"
				;;
			unionfs|aufs)
				if modprobe "${MODPROBE_OPTIONS}" "${opt}"; then
					FLL_UNION_MODULE="${opt}"
				fi
				;;
			union_opts=*)
				FLL_UNION_OPTIONS="${opt#union_opts=}"
				;;
		esac
	done
}
###############################################################################
# 	use information exported via proc and sysfs to make block device list
# 	bubble-sort cdrom devices to top of block device stack
###############################################################################
fll_finger_blockdevs()
{
	# cdrom detection via /proc/sys/dev/cdrom/info
	if [ -f /proc/sys/dev/cdrom/info ]; then
		probed_cdroms="$(awk '
			/name:/ {
				for (i = NF; i >= 3; i--) {
					print($i)
				}
			}
		' /proc/sys/dev/cdrom/info)"
	fi

	# give priority to cdrom devices, skip them for fromiso
	if [ "${probed_cdroms}" ] && [ "${FLL_FROMISO}" != "yes" ]; then
		for cdrom in ${probed_cdroms}; do
			if [ -b "/dev/${cdrom}" ]; then
				echo "/dev/${cdrom}"
			fi
		done
	fi

	# generic block device detection
	for dev in /sys/block/*; do
		dev=${dev#/sys/block/}
		
		case "${dev}" in
			# skip ram, loop and floppy devices
			ram[0-9]*|loop[0-9]*|fd[0-9]*)
				continue
				;;
		esac

		# skip block devices already detected as cdroms
		if [ "${probed_cdroms}" ]; then
			for cdrom in ${probed_cdroms}; do
				if [ "${cdrom}" = "${dev}" ]; then
					continue 2
				fi
			done
		fi

		# use shell wildcard to expand subdevices
		for subdev in $(echo /dev/${dev}*); do
			if [ -b "${subdev}" ]; then
				echo "${subdev}"
			fi
		done
	done
}
###############################################################################
# 	identify filesystem type of block device
###############################################################################
fll_finger_fstype()
{
	unset FSTYPE FSSIZE
	
	# fstype from klibc-utils
	eval $(fstype < ${1})

	if ( [ -z "${FSTYPE}" ] || [ "${FSTYPE}" = "unknown" ] ) && \
		[ -x /lib/udev/vol_id ]; then
		FSTYPE=$(/lib/udev/vol_id -t ${1})
	fi
	
	if [ "${FSTYPE}" ] && [ "${FSTYPE}" != "unknown" ]; then
		export FSTYPE
		export FSSIZE
		return 0
	fi
	
	return 1
}
###############################################################################
#	ugly hack to create "missing" /dev/loop{0..7} device nodes
###############################################################################
fll_setup_dev_loop()
{
	grep -q ^loop /proc/modules || modprobe "${MODPROBE_OPTIONS}" loop
	
	for n in 0 1 2 3 4 5 6 7; do
		[ -e /dev/loop${n} ] || mknod /dev/loop${n} b 7 ${n}
	done		
}
###############################################################################
#	generic mount function usage: fll_mount fs src mnt options
###############################################################################
fll_mount()
{
	FS="${1}"
	SRC="${2}"
	DST="${3}"
	shift 3
	
	case "${FS}" in
		iso9660|squashfs)
			if [ -f "${SRC}" ] && [ ! -b "${SRC}" ]; then
				fll_setup_dev_loop
				FLL_MOUNT_OPTS="ro,loop"
			else
				FLL_MOUNT_OPTS="ro"
			fi
			;;
		ntfs)
			# uid + gid of 1000: may not be true in some cases
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@},uid=1000,gid=1000"
			else
				FLL_MOUNT_OPTS="ro,uid=1000,gid=1000"
			fi
			;;
		vfat)
			# We REALLY need this for FLL_IMAGE on DOS-filesystems
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@},shortname=winnt"
			else
				FLL_MOUNT_OPTS="shortname=winnt"
			fi
			;;
		*)
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@}"
			fi
			;;
	esac
	
	if [ "${FLL_MOUNT_OPTS}" ]; then
		if mount -t ${FS} -o ${FLL_MOUNT_OPTS} ${SRC} ${DST} >/dev/null 2>&1; then
			return 0
		fi
	else
		if mount -t ${FS} ${SRC} ${DST} >/dev/null 2>&1; then
			return 0
		fi
	fi

	return 1
}
###############################################################################
#	Calculate total, used and unused memory: MEMTOTAL MEMUSED MEMFREE
###############################################################################
fll_meminfo()
{
	awk '
		/^MemTotal:/			{ total=$2 }
		/^(MemFree|Buffers|Cached):/	{ free+=$2 }
		END {
			printf("MEMTOTAL=%d\n",	int(total) / 1024)
			printf("MEMFREE=%d\n",	int(free) / 1024)
			printf("MEMUSED=%d\n",	(int(total) - int(free)) / 1024)
		}
	' /proc/meminfo
}
###############################################################################
# 	define mountroot() for init
###############################################################################
mountroot()
{
	# source distro-defaults
	. /etc/default/distro
	
	# parse fll option on cmdline
	fll_parse_cmdline

	#######################################################################
	#	print geeky informational messages
	#######################################################################
	# Welcome message
	printf "\n${WHITE}Welcome to ${FLL_DISTRO_NAME} (${FLL_ARCH}) live linux!${NORMAL}\n\n"

	# Print kernel info
	printf "${GREEN}Linux Kernel\t${WHITE}[ ${YELLOW}$(uname -r)${WHITE} ]${NORMAL}\n\n"

	# Print CPU info
	printf "${GREEN}"
	awk -F: '
		/^processor/	{ printf("Processor'${YELLOW}'"$2"'${GREEN}' is\t")	}
		/^model name/	{ printf("'${WHITE}'['${YELLOW}'"$2"'${WHITE}' ] ")	}
		/^cpu MHz/	{ printf("[ '${YELLOW}'%d MHz'${WHITE}' ] ", int($2))	}
		/^cache size/	{ printf("['${YELLOW}'"$2" Cache'${WHITE}' ]")		}
		/^$/		{ printf("\n'${GREEN}'")				}
	' /proc/cpuinfo
	printf "${NORMAL}\n"

	
	# Print System Memory info
	eval $(fll_meminfo)
	printf "${GREEN}System Memory\t${WHITE}"
	printf "[ ${YELLOW}${MEMUSED}M used ${WHITE}] "
	printf "[ ${YELLOW}${MEMFREE}M free${WHITE} ] "
	printf "[ ${YELLOW}${MEMTOTAL}M total${WHITE} ]"
	printf "${NORMAL}\n\n"

	##
	# debug checkpoint
	##
	maybe_break fll-premount

	#######################################################################
	#	find live-media
	#######################################################################
	if [ -z "${FLL_BLOCKDEVS}" ]; then
		# list of block devices to be probed for live media
		FLL_BLOCKDEVS=$(fll_finger_blockdevs)
	fi
	
	if [ "${FLL_BLOCKDEVS}" ]; then
		printf "${GREEN}Probing devices\t${WHITE}[ ${NORMAL}"
	else
		printf "${RED}Failed to detect any devices that may contain live media!${NORMAL}\n\n"
		panic
	fi
	
	for dev in ${FLL_BLOCKDEVS}; do
		unset FLL_BLOCKMNT FLL_DOUMOUNT FLL_MEDIA_FOUND
		##
		# determine filesystem type of block device
		##
		if fll_finger_fstype "${dev}"; then
			printf "${YELLOW}${dev#/dev/}${NORMAL} "
			##
			# we have FSTYPE
			##
			mkdir -p "/mnt/${dev#/dev/}"
			FLL_BLOCKMNT="/mnt/${dev#/dev/}"
			##
			# mount block device for probe
			##
			if fll_mount "${FSTYPE}" "${dev}" "${FLL_BLOCKMNT}" ro; then
				##
				# probe for iso image
				##
				if [ "${FLL_FROMISO}" = "yes" ]; then
					if [ -f "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME}" ]; then
						FLL_MEDIA_FOUND="${dev}"
						printf "${WHITE}]${NORMAL}\n\n"
						printf "${GREEN}Detected ${YELLOW}${FLL_MEDIA_NAME}${GREEN} "
						printf "on ${YELLOW}${FLL_MEDIA_FOUND}${GREEN}.${NORMAL}\n"
						##
						# loop mount iso on FLL_MEDIA_MOUNTPOINT
						##
						if fll_finger_fstype "${FLL_MEDIA_DIR}/${FLL_MEDIA_NAME}"; then
							mkdir -p "${rootmnt}/${FLL_MEDIA_MOUNTPOINT}"
							if fll_mount "${FSTYPE}" "${FLL_BLOCKMNT}/${FLL_MEDIA_DIR}/${FLL_MEDIA_NAME}" \
								"${rootmnt}/${FLL_MEDIA_MOUNTPOINT}"; then
								##
								# add block device mount point to umount stack
								##
								if [ "${FLL_TORAM}" ]; then
									FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
								fi
								##
								# update live image probe location, and dev
								##
								FLL_BLOCKMNT="${rootmnt}/${FLL_MEDIA_MOUNTPOINT}"
								dev="iso"
							else
								# XXX: this should not fail
								unset FLL_MEDIA_FOUND
							fi
						else
							# XXX: this should not fail
							unset FLL_MEDIA_FOUND
						fi
					fi
				fi
				##
				# probe for compressed filesystem
				##
				if [ -f "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" ]; then
					if fll_finger_fstype "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}"; then
						FLL_MEDIA_FOUND="${dev}"
						printf "${WHITE}]${NORMAL}\n\n"
						printf "${GREEN}Detected live media ${YELLOW}${FSTYPE}${GREEN} "
						printf "filesystem on ${YELLOW}${FLL_MEDIA_FOUND}${GREEN}.${NORMAL}\n"
						##
						# copy to tmpfs
						##
						if [ "${FLL_TORAM}" ]; then
							#
							# required tmpfs size: compressed filesystem size + 5% buffer
							#
							FLL_TORAM_FSSIZE=$(du -s "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" |
								awk '{ printf("%d\n", int(($1 * 1.1) / 1024)) }')
							# recalculate free system memory
							eval $(fll_meminfo)
							if [ "${MEMFREE}" -gt "${FLL_TORAM_FSSIZE}" ]; then
								##
								# prepare tmpfs
								##
								mkdir -p "/dev/shm/${FLL_IMAGE_DIR}"
								mount -n -t tmpfs -o size="${FLL_TORAM_FSSIZE}m" tmpfs "/dev/shm/${FLL_IMAGE_DIR}"
								##
								# do the copy
								##
								printf "${GREEN}Copying live media from ${YELLOW}${dev}${GREEN} "
								printf "to ${YELLOW}ram${GREEN}, please be patient...${NORMAL}"
								if cp "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" "/dev/shm/${FLL_IMAGE_DIR}"; then
									##
									# add old mnt pnt to umount stack, update FLL_BLOCKMNT and dev
									##
									FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
									FLL_BLOCKMNT="/dev/shm"
									dev="ram"
									printf "${YELLOW}done${NORMAL}\n"
								else
									if [ "${FLL_FROMISO}" = "yes" ]; then
										# we failed to copy iso contents to ram: reset umount stack
										unset FLL_DOUMOUNT
									fi
									printf "${RED}failed!${NORMAL}\n"
								fi
							else
								printf "${RED}Insufficient free memory to copy live media into ram!${NORMAL}\n"
								printf "${RED}Required free memory: ${YELLOW}${FLL_TORAM_FSSIZE} M${NORMAL}\n"
								if [ "${FLL_FROMISO}" = "yes" ]; then
									# we failed to copy iso contents to ram: reset umount stack
									unset FLL_DOUMOUNT
								fi
							fi
						fi
						##
						# mount compressed filesystem, source directory: FLL_BLOCKMNT
						##
						FLL_INITRAMFS_ROOTMNT="${rootmnt}${FLL_MOUNTPOINT}"
						mkdir -p "${FLL_INITRAMFS_ROOTMNT}"
						if fll_mount "${FSTYPE}" "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" "${FLL_INITRAMFS_ROOTMNT}"; then
							printf "${GREEN}Mounted ${YELLOW}${FSTYPE}${GREEN} filesystem.${NORMAL}\n"
						else
							# XXX: this should not fail
							printf "${RED}Failed to mount ${YELLOW}${FSTYPE}${GREEN} filesystem!${NORMAL}\n"
							unset FLL_MEDIA_FOUND
							FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
						fi
					else
						# XXX: this should not fail
						printf "${RED}!${NORMAL} "
						unset FLL_MEDIA_FOUND
						FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
					fi
				else
					##
					# next please, umount dev
					##
					FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
				fi
			fi
		fi
		##
		# umount mount points in FLL_DOUMOUNT stack
		##
		for mnt in ${FLL_DOUMOUNT}; do
			umount "${mnt}"
		done
		##
		# break upon successful mount of live-media
		##
		if [ "${FLL_MEDIA_FOUND}" ]; then
			break
		fi

		printf "${WHITE}[${NORMAL} "
	done

	##
	# debug checkpoint
	##
	maybe_break fll-mount

	##
	# panic on failure to detect live media
	##
	if [ -z "${FLL_MEDIA_FOUND}" ]; then
		printf "\n${RED}Failed to detect live media!${NORMAL}\n"
		panic
	fi

	##
	# create base symlinks in ${rootmnt} to ${FLL_INITRAMFS_ROOTMNT}
	##
	for dir in ${FLL_INITRAMFS_ROOTMNT}/*; do
		if [ -d "${dir}" ]; then
			case "${dir##*/}" in
				dev|proc|sys|home|tmp)
					# these are handled explicitly
					continue
					;;
				*)
					ln -s "${FLL_MOUNTPOINT}/${dir##*/}" \
						"${rootmnt}/${dir##*/}"
					;;
			esac
		fi
	done

	##
	# create dirs for dev, proc & sys
	##
	mkdir --mode 0755 "${rootmnt}/tmp"
	mkdir "${rootmnt}/proc" "${rootmnt}/sys"
}
###############################################################################
