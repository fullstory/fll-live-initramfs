#!/bin/sh

###############################################################################
#	F.U.L.L.S.T.O.R.Y initramfs live media init functions
#
#	Copyright:	(C) 2007 Kel Modderman <kel@otaku42.de>
#			(C) 2007 Stefan Lippers-Hollmann <s.l-h@gmx.de>
#	License:	GPLv2
#
#	F.U.L.L.S.T.O.R.Y Project Homepage:
#	http://developer.berlios.de/projects/fullstory
###############################################################################
#	utility function to help with identifying device strings within a list
###############################################################################
fll_string_not_in_strings()
{
	VAR="${1}"
	shift

	for var in ${@}; do
		[ "${VAR}" = "${var}" ] && return 1
	done

	return 0
}
###############################################################################
# 	use information exported via proc and sysfs to make block device list
# 	bubble-sort cdrom devices to top of block device stack
###############################################################################
fll_finger_blockdevs()
{
	if [ "${FLL_FROMHD}" != "yes" ]; then
		#
		# cdrom detection via /proc/sys/dev/cdrom/info
		#
		if [ -f /proc/sys/dev/cdrom/info ]; then
			FLL_PROBED_CDROMS="$(awk '
				/name:/ {
					for (i = NF; i >= 3; i--) {
						print($i)
					}
				}
			' /proc/sys/dev/cdrom/info)"
		fi

		if [ "${FLL_PROBED_CDROMS}" ]; then
			for cdrom in ${FLL_PROBED_CDROMS}; do
				if [ -b "/dev/${cdrom}" ]; then
					echo "/dev/${cdrom}"
				fi
			done
		fi
	fi

	#
	# fromhd/fromiso/persist cheatcode required for additional block device detection
	#
	if [ "${FLL_FROMHD}" != "yes" ] && [ "${FLL_PERSIST}" != "yes" ]; then
		return 0
	fi

	#
	# generic block device detection
	#
	for dev in /sys/block/*; do
		dev=${dev#/sys/block/}
		
		case "${dev}" in
			#
			# skip ram, loop and floppy devices
			#
			ram[0-9]*|loop[0-9]*|fd[0-9]*)
				continue
				;;
		esac

		#
		# skip block devices already detected as cdroms
		#
		if [ "${FLL_PROBED_CDROMS}" ]; then
			if ! fll_string_not_in_strings "${dev}" ${FLL_PROBED_CDROMS}; then
				#
				# returned 1, already identified as cdrom device
				#
				continue
			fi
		fi
		
		#
		# use shell wildcard to expand subdevices
		#
		for subdev in $(echo /dev/${dev}*); do
			if [ -b "${subdev}" ]; then
				echo "${subdev}"
			fi
		done
	done
}
###############################################################################
# 	identify filesystem type of block device
###############################################################################
fll_finger_fstype()
{
	unset FSTYPE FSSIZE
	
	#
	# fstype from klibc-utils
	#
	eval $(fstype < ${1} 2>/dev/null)

	if ( [ -z "${FSTYPE}" ] || [ "${FSTYPE}" = "unknown" ] ) && \
		[ -x /lib/udev/vol_id ]; then
		FSTYPE=$(/lib/udev/vol_id -t ${1} 2>/dev/null)
	fi

	if [ "${FSTYPE}" ] && [ "${FSTYPE}" != "unknown" ]; then
		export FSTYPE
		export FSSIZE
		return 0
	fi
	
	return 1
}
###############################################################################
#	modprobe loop and wait for device node creation
###############################################################################
fll_setup_dev_loop()
{
	#
	# load loop device support
	#
	grep -q ^loop /proc/modules || modprobe "${MODPROBE_OPTIONS}" loop
	
	#
	# loop around for max of 5 seconds and wait for /dev/loop* device nodes
	#
	LOOP_WAIT="10"

	while [ "${LOOP_WAIT}" -gt 0 ]; do
		for l in /dev/loop*; do
			if [ -e "${l}" ]; then
				return 0
			fi
		done
		/bin/sleep 1
		LOOP_WAIT=$(( ${LOOP_WAIT} - 1 ))
	done

	panic "${R}Unable to setup loop mounted device, no loop device nodes exist${N}"
}
###############################################################################
#	generic mount function usage: fll_mount fs src mnt options
###############################################################################
fll_mount()
{
	FS="${1}"
	SRC="${2}"
	DST="${3}"
	shift 3

	case "${FS}" in
		iso9660|squashfs)
			if [ -f "${SRC}" ] && [ ! -b "${SRC}" ]; then
				fll_setup_dev_loop
				FLL_MOUNT_OPTS="ro,loop"
			else
				FLL_MOUNT_OPTS="ro"
			fi
			;;
		ntfs)
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@},dmask=0022,fmask=0133"
			else
				FLL_MOUNT_OPTS="ro,dmask=0022,fmask=0133"
			fi
			;;
		vfat)
			#
			# we need this for FLL_IMAGE on DOS-filesystems
			#
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@},shortname=winnt,umask=0"
			else
				FLL_MOUNT_OPTS="shortname=winnt,umask=0"
			fi
			;;
		suspend|swap|luks|lvm*)
			#
			# filesystem blacklist
			#
			return 1
			;;
		*)
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="noatime,${@}"
			fi
			;;
	esac

	if [ "${FLL_MOUNT_OPTS}" ]; then
		if mount -t ${FS} -o ${FLL_MOUNT_OPTS} ${SRC} ${DST} >/dev/null 2>&1; then
			return 0
		fi
	else
		if mount -t ${FS} ${SRC} ${DST} >/dev/null 2>&1; then
			return 0
		fi
	fi

	return 1
}
###############################################################################
#	umount and remove a stack of mount points
###############################################################################
fll_umount()
{
	[ "${#}" -ge 1 ] || return 0
	
	for m in ${@}; do
		if grep -q "${m}" /proc/mounts; then
			umount "${m}" && rmdir "${m}"
		fi
	done
}
###############################################################################
#	display processor name and highlights
###############################################################################
fll_cpuinfo()
{
	printf "${G}"
	awk -F: '
		/^processor/ { printf("Processor'${Y}'"$2"'${G}' is\t") }
		/^model name/ {
			gsub(/(\([Tt][Mm]\)|\([Rr]\))/,"",$2)
			gsub(/[ ]+/," ",$2)
			printf("'${W}'['${Y}'"$2"'${W}' ] ")
		}
		/^cpu MHz/ { printf("[ '${Y}'%d MHz'${W}' ] ", int($2)) }
		/^cache size/ { printf("['${Y}'"$2" Cache'${W}' ]") }
		/^$/ { printf("\n'${G}'") }
	' /proc/cpuinfo
	printf "${N}"
}
###############################################################################
#	calculate total, used and unused memory: MEMTOTAL MEMUSED MEMFREE
###############################################################################
fll_meminfo()
{
	awk '
		/^MemTotal:/ { total=$2 }
		/^(MemFree|Buffers|Cached):/ { free+=$2 }
		END {
			printf("MEMTOTAL=%d\n",	int(total) / 1024)
			printf("MEMFREE=%d\n",	int(free) / 1024)
			printf("MEMUSED=%d\n",	(int(total) - int(free)) / 1024)
		}
	' /proc/meminfo
}
###############################################################################
#	utility function to display update when cp'ing live media into ram
###############################################################################
fll_copy_with_perc()
{
	if [ ! -f "${1}" ] || [ ! -d "${2}" ]; then
		return 1
	fi

	#
	# background the copy, grab the process id
	#
	cp "${1}" "${2}/${1##*/}" &
	
	awk -v pid="${!}" -v origfile="${1}" -v destfile="${2}/${1##*/}" '
		function size_of(file,    cmd, size)
		{
			cmd = "du -s " file
			if ((cmd | getline) > 0) {
				size = sprintf("%d\n", int($1))
				close(cmd)
				if (size > 0)
					return size
			}

			return 0
		}

		BEGIN {
			do {
				if (system("test -f " destfile) == 0) {
					break
				}
				else if (system("/bin/sleep 1") == 0) {
					wait++
				}
				else {
					exit(1)
				}
			} while (wait < 15)

			size_dest = perc = 0
			size_orig = size_of(origfile)
			if (size_orig <= 0)
				exit(1)

			do {
				perc = int(100 * size_of(destfile) / size_orig)
				if (perc < 100) {
					printf("'${Y}'")
					printf("\b\b\b%02d%s", perc, "%")
					printf("'${N}'")
				}
			} while (system("kill -0 " pid " 2>/dev/null") == 0 &&
				 system("/bin/sleep 2") == 0)

			#
			# destfile size is > origfile size on tmpfs
			#
			if (size_of(destfile) >= size_orig) {
				printf("'${Y}'")
				printf("\b\b\b%s\n", "100%")
				printf("'${N}'")
				exit(0)
			}
			else {
				printf("'${R}'")
				printf("\nFailed to copy %s to ram\n", origfile)
				printf("'${N}'")			
				exit(1)
			}
		}'
	
	return ${?}
}
###############################################################################
#	md5sum checker
###############################################################################
fll_md5sum_check()
{
	if [ ! -f "${1}/md5sums" ]; then
		printf "No md5sums file found on live media.\n"
		return 1
	fi

	awk -v dir=${1} '
		{
			sub(/^\*/, "", $2)
			
			md5 = $1
			file = $2

			printf("'${W}'")
			printf("* %s\n|--> %s\n`--> ", file, md5)
			printf("'${N}'")
			
			if (("md5sum " dir "/" file | getline) > 0) {
				if (md5 == $1) {
					printf("'${G}'")
					printf("%s  OK\n\n", $1)
					printf("'${N}'")
					next
				}
				else {
					printf("'${R}'")
					printf("%s  FAILED\n\n", $1)
					printf("'${N}'")
				}
			}
			else {
				printf("'${R}'")
				printf("Unable to calculate md5sum!\n\n")
				printf("'${N}'")
			}
			
			failed++
		}
		
		END{
			if (failed) {
				printf("'${R}'")
				printf("*******************************\n")
				printf("***** MD5SUM CHECK FAILED *****\n")
				printf("*******************************\n")
				printf("'${N}'")
				exit(1)
			}
			
			exit(0)
		}' "${1}/md5sums"
	
	return ${?}
}
###############################################################################
# 	define mountroot() for init
###############################################################################
mountroot()
{
	#
	# colourful escape sequences
	#
	N="[0;39m"	# Normal color
	R="[1;31m"	# Failure message
	G="[1;32m"	# Success message
	Y="[1;33m"	# Variable Descriptions
	W="[1;37m"	# Brackets
	
	#
	# force our arch string for i386
	#
	case "${DPKG_ARCH}" in
		i?86)
			FLL_ARCH="i686"
			;;
		*)
			FLL_ARCH="${DPKG_ARCH}"
			;;
	esac

	#
	# source distro-defaults
	#
	. /etc/default/distro
	
	#
	# parse fll options given on cmdline
	#
	for opt in $(cat /proc/cmdline); do
		case "${opt}" in
			fll=debug)
				set -x
				;;
			fromhd*)
				FLL_FROMHD="yes"
				# define dev node
				case "${opt}" in
					fromhd=*)
						FLL_FROMHD_DEV="${opt#fromhd=}"
						;;
				esac
				;;
			fromiso*)
				FLL_FROMHD="yes"
				FLL_FROMISO="yes"
				# define iso name
				case "${opt}" in
					fromiso=*)
						FLL_MEDIA_NAME="${opt#fromiso=}"
						;;
				esac
				;;
			image_dir=*)
				FLL_IMAGE_DIR="${opt#image_dir=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			image_name=*)
				FLL_IMAGE_FILE="${opt#image_name=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			persist*)
				FLL_PERSIST="yes"
				FLL_PERSIST_FILE="${FLL_DISTRO_NAME}-rw"
				case "${opt}" in
					persist=*)
						FLL_PERSIST_FILE="${opt#persist=}"
						FLL_UNION_COWDIR="${opt#persist=}"
						;;
				esac
				;;
			quiet)
				if [ -f /proc/sys/kernel/printk ]; then
					echo "0" > /proc/sys/kernel/printk
				fi
				;;
			testcd|testdvd|md5sum)
				FLL_MD5SUM_CHECK="yes"
				;;
			toram)
				FLL_TORAM="yes"
				;;
			unionfs|aufs)
				FLL_UNION_MODULE="${opt}"
				;;
		esac
	done

	#
	# print geeky informational messages
	#
	printf "\n${W}Welcome to ${FLL_DISTRO_NAME} (${FLL_ARCH}) live linux${N}\n\n"

	#
	# Print kernel info
	#
	printf "${G}Linux Kernel\t${W}[ ${Y}$(uname -r)${W} ]${N}\n"

	#
	# Print CPU info
	#
	fll_cpuinfo

	#
	# Print System Memory info
	#
	eval $(fll_meminfo)
	printf "${G}System Memory\t${W}"
	printf "[ ${Y}${MEMUSED}M used ${W}] "
	printf "[ ${Y}${MEMFREE}M free${W} ] "
	printf "[ ${Y}${MEMTOTAL}M total${W} ]"
	printf "${N}\n"

	#
	# debug checkpoint
	#
	maybe_break fll-premount

	#
	# total time in seconds to do device scans for; rootdelay= on kernel cmdline
	# upper limit on how long we wait for devices to show up before bailing out
	#
	if [ "${ROOTDELAY}" ] && [ "${ROOTDELAY}" -gt 0 ]; then
		FLL_ROOTDELAY="${ROOTDELAY}"
	else
		FLL_ROOTDELAY="30"
	fi
	
	#
	# interval between device scans
	#
	FLL_MOUNT_INTERVAL="3"

	#
	# these variables are created during $FLL_ROOTDELAY time loop
	#
	unset FLL_BLOCKDEVS_OLD FLL_MOUNT_LOOP
	
	while [ "${FLL_ROOTDELAY}" -gt 0 ]; do
		#
		# refresh these for each loop
		#
		unset FLL_BLOCKDEVS FLL_BLOCKDEVS_NOW FLL_BLOCKDEVS_PROBED

		#
		# sleep time, we skip FLL_ROOTDELAY interval for first pass for extra fast boot
		#
		if [ "${FLL_MOUNT_LOOP}" ]; then
			if [ "${FLL_MOUNT_LOOP}" = 1 ]; then
				printf "${G}Waiting up to ${Y}${FLL_ROOTDELAY}${G}s for devices to settle${N}...\n"
			fi
			/bin/sleep "${FLL_MOUNT_INTERVAL}"
			FLL_ROOTDELAY=$(( ${FLL_ROOTDELAY} - ${FLL_MOUNT_INTERVAL} ))
		fi

		#
		# mount loop counter, it enforces sleep interval on next loop
		#
		FLL_MOUNT_LOOP=$(( ${FLL_MOUNT_LOOP} + 1 ))
		
		#
		# determine block devices to be probed on this loop
		#
		if [ "${FLL_FROMHD_DEV}" ]; then
			#
			# user defined block device
			#
			case "${FLL_FROMHD_DEV}" in
				LABEL=*)
					FLL_BLOCKDEVS="/dev/disk/by-label/${FLL_FROMHD_DEV#LABEL=}"
					;;
				UUID=*)
					FLL_BLOCKDEVS="/dev/disk/by-uuid/${FLL_FROMHD_DEV#UUID=}"
					;;
				*)
					FLL_BLOCKDEVS="${FLL_FROMHD_DEV}"
					;;
			esac
		else
			#
			# current list of block devices that may be probed for live media
			#
			FLL_BLOCKDEVS_NOW=$(fll_finger_blockdevs)
			#
			# FLL_BLOCKDEVS_OLD accounts for all devices probed so, it appends a copy of
			# FLL_BLOCKDEVS for every loop new devices are found
			# FLL_BLOCKDEVS is always a list of new devices that have not been probed so far
			#
			if [ "${FLL_BLOCKDEVS_OLD}" ]; then
				#
				# compare all devices probed so far with list of devices discovered now
				#
				for dev in ${FLL_BLOCKDEVS_NOW}; do
					if fll_string_not_in_strings ${dev} ${FLL_BLOCKDEVS_OLD}; then
						#
						# we have not yet probed these devices
						#
						FLL_BLOCKDEVS="${FLL_BLOCKDEVS} ${dev}"
					fi
				done
			else
				#
				# no devices probed so far, probe all that are currently detectable at this time
				#
				FLL_BLOCKDEVS="${FLL_BLOCKDEVS_NOW}"
			fi
		fi
	
		if [ -z "${FLL_BLOCKDEVS}" ]; then
			continue
		fi

		for dev in ${FLL_BLOCKDEVS}; do
			#
			# FLL_BLOCKMNT		- tracks current mount point
			#
			# FLL_DOUMOUNT		- stack of mount points to be umounted at end of
			#			  loop
			#
			# FLL_DOMOVEMOUNT	- stack of mount points to be move mounted if the
			#			  loop is broken
			#
			# FLL_MEDIA_FOUND	- set only when we have the live media compressed
			#			  filesystem located and mounted
			#
			unset FLL_BLOCKMNT FLL_DOUMOUNT FLL_DOMOVEMOUNT FLL_MEDIA_FOUND
		
			#
			# determine filesystem type of block device
			#
			if fll_finger_fstype "${dev}" >/dev/null 2>&1; then
				if [ -z "${FLL_BLOCKDEVS_PROBED}" ]; then
					printf "${G}Probing devices\t${N}"
				fi
				FLL_BLOCKDEVS_PROBED=$(( ${FLL_BLOCKDEVS_PROBED} + 1 ))
				printf "${W}[${Y} ${dev##*/}${W} ]${N} "
				#
				# we have determined FSTYPE of the device, set FLL_BLOCKMNT
				#
				FLL_BLOCKMNT="/fll/${dev##*/}"
				mkdir -p "${FLL_BLOCKMNT}"
				#
				# save origin of media in variable for persitency
				#
				if [ "${FLL_PERSIST}" = "yes" ]; then
					FLL_PERSIST_BLOCKDEV="${dev}"
					FLL_PERSIST_BLOCKFSTYPE="${FSTYPE}"
					FLL_PERSIST_BLOCKMNT="${FLL_BLOCKMNT}"
				fi
				#
				# mount block device on FLL_BLOCKMNT for probe
				#
				if fll_mount "${FSTYPE}" "${dev}" "${FLL_BLOCKMNT}" ro; then
					#
					# add current FLL_BLOCKMNT to FLL_DOMOVEMOUNT stack
					#
					FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
					#
					# probe for iso image
					#
					if [ "${FLL_FROMISO}" = "yes" ]; then
						if [ -f "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME#/}" ]; then
							#
							# located iso, update dev description
							#
							FLL_MEDIA_FOUND="${dev}"
							printf "\n\n"
							printf "${G}Detected ${Y}${FLL_MEDIA_NAME}${G} "
							printf "on ${Y}${FLL_MEDIA_FOUND##*/}${G}.${N}\n"
							if fll_finger_fstype "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME}" >/dev/null 2>&1; then
								if [ "${FSTYPE}" != "iso9660" ]; then
									panic "${Y}${FLL_MEDIA_NAME}${R} not an iso9660 filesystem${N}"
								fi
								mkdir -p /fll/fromiso
								#
								# loop mount iso on FLL_MEDIA_MOUNTPOINT
								#	
								if fll_mount "${FSTYPE}" "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME}" /fll/fromiso; then
									if [ "${FLL_TORAM}" ]; then
										#
										# add block device mount point to umount stack
										#
										FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
									fi
									#
									# update FLL_BLOCKMNT, FLL_DOMOVEMOUNT stack, and dev description
									#
									FLL_BLOCKMNT="/fll/fromiso"
									FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
									dev="iso"
								else
									fll_umount ${FLL_DOUMOUNT}
									panic "${R}Failed to mount ${Y}${FSTYPE}${R} filesystem from iso image${N}"
								fi
							else
								fll_umount ${FLL_DOUMOUNT}
								panic "${R}Failed to identify filesystem type of iso${N}"
							fi
						fi
					fi
					#
					# probe for compressed filesystem
					#
					if [ -f "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" ]; then
						#
						# found FLL compressed filesystem
						# set/update FLL_MEDIA_FOUND variable (possibly already set via fromiso)
						#
						if [ "${FLL_MEDIA_FOUND}" ]; then
							printf "\n"
						else
							printf "\n\n"
						fi
						FLL_MEDIA_FOUND="${dev}"
						#
						# debug checkpoint
						#
						maybe_break fll-found
						#
						# md5sum check
						#
						if [ "${FLL_MD5SUM_CHECK}" = "yes" ]; then
							printf "${G}Performing ${Y}md5sum${G} integrity check of live media${N}...\n\n"
							if fll_md5sum_check ${FLL_BLOCKMNT}; then
								printf "${G}All md5sums verified successfully.${N}\n\n"
							else
								fll_umount ${FLL_DOUMOUNT}
								panic "${R}Failed md5sum check!${N}"
							fi
						fi
						#
						# prepare live filesystem
						#
						if fll_finger_fstype "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" >/dev/null 2>&1; then
							printf "${G}Detected live ${Y}${FSTYPE}${G} "
							printf "filesystem on ${Y}${FLL_MEDIA_FOUND}${N}\n"
							#
							# copy to tmpfs
							#
							if [ "${FLL_TORAM}" = "yes" ]; then
								#
								# required tmpfs size: compressed filesystem size + 10% buffer
								#
								eval $(fll_meminfo)
								FLL_TORAM_FSSIZE=$(du -s "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" | \
									awk '{ printf("%d\n", int($1 * 1.1 / 1024)) }')
								#
								# memory required to operate normally after iso has consumed memory
								# at least 32M is required
								#
								FLL_TORAM_MEMREQ=$(( ${FLL_TORAM_FSSIZE} + 32 ))
								#
								# do we have enough free memory for toram?
								#
								if [ "${MEMFREE}" -gt "${FLL_TORAM_MEMREQ}" ]; then
									#
									# prepare tmpfs, aka ramdisk
									#
									mkdir -p /fll/toram
									mount -n -t tmpfs -o size="${FLL_TORAM_FSSIZE}m" tmpfs /fll/toram
									mkdir -p "/fll/toram/${FLL_IMAGE_DIR}"
									#
									# copy compressed filesystem to tmpfs
									#
									printf "${G}Copying live filesystem from ${Y}${dev}${G} to ${Y}ram${G}:${N}    "
									if fll_copy_with_perc "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" "/fll/toram/${FLL_IMAGE_DIR}"; then
										#
										# add old mnt pnt to umount stack, update FLL_BLOCKMNT and dev
										#
										FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
										FLL_BLOCKMNT="/fll/toram"
										FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
										dev="ram"
									else
										if [ "${FLL_FROMISO}" = "yes" ]; then
											#
											# we failed to copy iso contents to ram: reset FLL_DOUMOUNT stack
											#
											unset FLL_DOUMOUNT
										fi
										#
										# umount the tmpfs or run-init will not be happy
										#
										rm -rf "/fll/toram/${FLL_IMAGE_DIR}"
										fll_umount /fll/toram
										printf "\n${G}Continuing boot from live media${N}...\n"
									fi
								else
									printf "${R}Insufficient free memory to copy live media into memory${N}\n"
									printf "${R}Required free memory: ${Y}${FLL_TORAM_MEMREQ}M${N}\n"
									printf "\n${G}Continuing boot from live media${N}...\n"
									if [ "${FLL_FROMISO}" = "yes" ]; then
										#
										# we failed to copy iso contents to ram: reset FLL_DOUMOUNT stack
										#
										unset FLL_DOUMOUNT
									fi
								fi
							fi
							#
							# mount compressed filesystem, source directory: FLL_BLOCKMNT
							#
							mkdir -p "${FLL_MOUNTPOINT}"
							if fll_mount "${FSTYPE}" "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" "${FLL_MOUNTPOINT}"; then
								if [ ! -e "${FLL_MOUNTPOINT}/boot/vmlinuz-$(uname -r)" ]; then
									printf "${R}Kernel mismatch: ${Y}vmlinuz-$(uname -r)${R} not found on live filesystem.\n${N}"
									printf "${R}Kernel(s) found on the live filesystem are:\n${N}"
									for kernel in ${FLL_MOUNTPOINT}/boot/vmlinuz-*; do
										[ -e "${kernel}" ] && printf "${Y}\t${kernel#*/boot/}\n${N}"
									done
									fll_umount ${FLL_DOUMOUNT}
									printf "${R}You must use the correct vmlinuz version (and matching initrd.img) to boot successfully.\n${N}"
									printf "${R}The correct vmlinuz and initrd.img files can be found in the /boot folder of live media.\n${N}"
									panic
								fi
								printf "${G}Mounted ${Y}${FSTYPE}${G} filesystem on ${Y}${FLL_MOUNTPOINT}${N}\n\n"
								FLL_DOMOVEMOUNT="${FLL_MOUNTPOINT} ${FLL_DOMOVEMOUNT}"
							else
								fll_umount ${FLL_DOUMOUNT}
								panic "${R}Failed to mount ${Y}${FSTYPE}${R} filesystem${N}"
							fi
						else
							fll_umount ${FLL_DOUMOUNT}
							panic "${R}Failed to identify filesystem type of live media image${N}"
						fi
					else
						#
						# probe next device, add current mount to FLL_DOUMOUNT stack
						#
						FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
					fi
				fi
			fi
		
			#
			# umount mount points in FLL_DOUMOUNT stack
			#
			fll_umount ${FLL_DOUMOUNT}
		
			#
			# break upon successful mount of live-media
			#
			if [ "${FLL_MEDIA_FOUND}" ]; then
				break 2
			fi
		done

		#
		# if we got here, we failed to find live media
		#
		
		if [ "${FLL_FROMHD_DEV}" ]; then
			continue
		fi
		
		#
		# keep account of what devices we have probed so far
		#
		FLL_BLOCKDEVS_OLD="${FLL_BLOCKDEVS_OLD} ${FLL_BLOCKDEVS}"
		
		#
		# start new probe line
		#
		printf "\n"
	done

	#
	# panic on failure to detect live media
	#
	if [ -z "${FLL_MEDIA_FOUND}" ]; then
		panic "${R}Failed to detect live media${N}"
	fi

	#
	# debug checkpoint
	#
	maybe_break fll-postmount

	#
	# mount a tmpfs over $rootmnt, reserving 10% system memory
	# Note: $rootmnt must be mounted with a fs != rootfs prior to run-init
	#
	printf "${G}Mounting virtual memory ${Y}tmpfs${G} filesystem on ${Y}${rootmnt}${G}${N}..."
	if mount -n -t tmpfs -o size=90%,mode=755 tmpfs "${rootmnt}"; then
		printf "\n"
	else
		panic "${R}Failed to mount tmpfs over ${Y}${rootmnt}${N}"
	fi

	#
	# move all mounts in FLL_DOMOVEMOUNT stack to $rootmnt
	#
	if [ "${FLL_DOMOVEMOUNT}" ]; then
		printf "${G}Moving all mounted filesystems to ${Y}${rootmnt}${G}${N}..."
		for mnt in ${FLL_DOMOVEMOUNT}; do
			if grep -q "${mnt}" /proc/mounts; then
				mkdir -p "${rootmnt}${mnt}"
				mount -n -o move "${mnt}" "${rootmnt}${mnt}"
			fi
		done
		printf "\n"
	fi
	
	#
	# sanity check, ${rootmnt}${FLL_MOUNTPOINT} _must_ exist
	#
	if [ ! -d "${rootmnt}${FLL_MOUNTPOINT}" ]; then
		panic "${R}Failed to find ${Y}${FLL_MOUNTPOINT}${G} on ${Y}${rootmnt}${N}"
	fi

	if [ -z "${FLL_UNION_MODULE}" ]; then
		FLL_UNION_MODULE="aufs"
	fi

	if modprobe "${MODPROBE_OPTIONS}" "${FLL_UNION_MODULE}"; then
		: # union filesystem support
	else
		panic "${R}Failed to load union filesystem support: ${Y}${FLL_UNION_MODULE}${N}"
	fi

	#
	# unioned filesystem mount points
	# persist may already have set FLL_UNION_COWDIR
	#
	FLL_UNION_MOUNTPOINT="/fll/${FLL_UNION_MODULE}"
	[ -z "$FLL_UNION_COWDIR" ] && FLL_UNION_COWDIR="/fll/cow"

	#
	# prepare COW union filesystem, handle persistency
	#
	if [ "${FLL_PERSIST}" = "yes" ] && [ "${FLL_PERSIST_BLOCKMNT}" ]; then
		case "${FLL_PERSIST_BLOCKFSTYPE}" in
			ext*|reiser*|xfs|jfs|msdos|vfat)
				#
				# FLL_PERSIST_BLOCKMNT points to position of mounted fielsystem before it was moved
				# to the new root filesystem. Prepend ${rootmnt}.
				#
				FLL_UNION_COWMNTPNT="${rootmnt}${FLL_PERSIST_BLOCKMNT}"
				mkdir -p "${FLL_UNION_COWMNTPNT}"
				#
				# remount original fs containing live media rw (toram would umount it)
				#
				if grep -q "${FLL_UNION_COWMNTPNT}" /proc/mounts && mount -o remount,rw "${FLL_UNION_COWMNTPNT}" || \
					fll_mount ${FLL_PERSIST_BLOCKFSTYPE} ${FLL_PERSIST_BLOCKDEV} ${FLL_UNION_COWMNTPNT} rw; then
					printf "${G}Remounting persistent filesystem on ${Y}${FLL_PERSIST_BLOCKDEV##*/}${G}${N}...\n"
				else
					panic "${R}Failed to remount persistent filesystem on ${Y}${FLL_PERSIST_DEV##*/}${N}"
				fi
				#
				# mount a persistent filesystem-in-a-file on microsoft filesystems
				#
				if [ "${FLL_PERSIST_BLOCKFSTYPE}" = "msdos" ] || [ "${FLL_PERSIST_BLOCKFSTYPE}" = "vfat" ]; then
					if [ -f "${FLL_UNION_COWMNTPNT}/${FLL_PERSIST_FILE}" ] && \
						fll_finger_fstype "${FLL_UNION_COWMNTPNT}/${FLL_PERSIST_FILE}"; then
						printf "${G}Mounting ${Y}${FLL_PERSIST_FILE}${G} filesystem-in-a-file${N}..."
						#
						# identify filesystem of loopback file, mount it and update FLL_UNION_COWMNTPNT
						#
						mkdir -p "${rootmnt}/fll/persist"
						if fll_mount "${FSTYPE}" "${FLL_UNION_COWMNTPNT}/${FLL_PERSIST_FILE}" \
							"${rootmnt}/fll/persist" loop; then
							printf "\n"
							FLL_UNION_COWMNTPNT="${rootmnt}/fll/persist"
							#
							# We have now found a persistent file setup
							# We can revert any custom cowdir set by persist
							#
							FLL_UNION_COWDIR="/fll/cow"
						else
							panic "${R}Failed to mount ${Y}${FLL_PERSIST_FILE}${R} persistent filesystem-in-a-file${N}"
						fi
					else
						panic "${R}Invalid/missing ${Y}${FLL_PERSIST_FILE}${R} persistent filesystem-in-a-file${N}"
					fi
				fi
				;;
			*)
				#
				# we could support vfat|msdos with a loop mounted ext* filesystem-in-a-file
				#
				panic "${R}Cannot create persistent filesystem with type ${Y}${FLL_PERSIST_BLOCKFSTYPE}${N}"
				;;
		esac
	else
		FLL_UNION_COWMNTPNT="${rootmnt}"
	fi
		
	mkdir -p "${rootmnt}${FLL_UNION_MOUNTPOINT}" "${FLL_UNION_COWMNTPNT}${FLL_UNION_COWDIR}"
	
	#
	# union module specific options
	#
	case "${FLL_UNION_MODULE}" in
		aufs)
			FLL_UNION_OPTIONS="br:${FLL_UNION_COWMNTPNT}${FLL_UNION_COWDIR}:${rootmnt}${FLL_MOUNTPOINT}"
			;;
		unionfs)
			FLL_UNION_OPTIONS="dirs=${FLL_UNION_COWMNTPNT}${FLL_UNION_COWDIR}=rw:${rootmnt}${FLL_MOUNTPOINT}=ro"
			;;
	esac
	
	#
	# mount the union COW filesystem
	#
	printf "${G}Mounting ${Y}${FLL_UNION_MODULE}${G} union filesystem${N}..."
	if mount -t "${FLL_UNION_MODULE}" -o "${FLL_UNION_OPTIONS}" "${FLL_UNION_MODULE}" "${rootmnt}${FLL_UNION_MOUNTPOINT}"; then
		printf "\n"
	else
		panic "${R}Failed to prepare ${Y}${FLL_UNION_MODULE}${R} union filesystem${N}"
	fi

	#
	# debug checkpoint
	#
	maybe_break fll-unionmount

	printf "${G}Preparing live filesystem on ${Y}${rootmnt}${G}${N}...\n"
	
	#
	# create links on $rootmnt to real filesystem
	#
	for dir in ${rootmnt}${FLL_UNION_MOUNTPOINT}/*; do
		if [ -d "${dir}" ]; then
			case "${dir##*/}" in
				dev|proc|sys|tmp)
					#
					# these should stay out of the unioned filesystem mount point
					# keep them directly on the ramdisk, they are handled below
					#
					continue
					;;
				*)
					#
					# link everything else to read-write unioned filesystem
					#
					if [ -L "${dir}" ]; then
						#
						# /lib64 -> /lib symlink handling
						#
						ln -sf "$(readlink -f ${dir})" "${rootmnt}/${dir##*/}"
					else
						#
						# bind mount links to read write union
						#
						mkdir -p "${rootmnt}/${dir##*/}"
						mount -n -o bind "${dir}" "${rootmnt}/${dir##*/}"
					fi
					;;
			esac
		fi
	done

	#
	# debug checkpoint
	#
	maybe_break fll-bindmount

	#
	# prepare /proc /sys
	#
	for dir in proc sys; do
		mkdir -p "${rootmnt}/${dir}"
	done

	#
	# tmp with correct permissions for users
	#
	mkdir -p -m 1777 "${rootmnt}/tmp"

	#
	# prepare /dev
	#
	mkdir -p -m 0755 "${rootmnt}/dev"

	printf "${G}Reconfiguring ${Y}sysvinit runlevels${G} for live boot${N}...\n"
	#
	# sanitise live SysV runlevel configuration
	#
	if [ ! -f "${rootmnt}/etc/default/fll-init" ]; then
		panic "${R}fll-init initscript blacklist not found${N}"
	fi

	while read init; do
		if [ -x "${rootmnt}/etc/init.d/${init}" ]; then
			rm -f ${rootmnt}/etc/rc[0-6S]\.d/[SK]??${init}
		fi
	done < "${rootmnt}/etc/default/fll-init"

	#
	# debug checkpoint
	#
	maybe_break fll-bottom

	#
	# alsa should not be persistent
	#
	rm -f ${rootmnt}/var/lib/alsa/asound.state

	#
	# disable persistent udev rules. we have "persistency" logic for data but
	# we should remain hardware agnostic
	#
	rm -f ${rootmnt}/etc/udev/rules.d/z25_persistent-*.rules
	
	#
	# disable movement of static $rootmnt/dev by scripts/init-bottom/udev
	#
	export no_static_dev="1"

	#
	# workaround cosmetic issue with selinux on live boot. It is doubtful that
	# anyone would find selinux a useful feature to have on an live-cd
	#
	export SELINUX_INIT=NO

	printf "\n${G}Starting ${Y}init${G} process${N}...\n\n"
}
###############################################################################
