#!/bin/sh

###############################################################################
#	F.U.L.L.S.T.O.R.Y initramfs live media init functions
#
#	Copyright:	(C) 2007 F.U.L.L.S.T.O.R.Y Project
#	License:	GPLv2
#
#	F.U.L.L.S.T.O.R.Y Project Homepage:
#	http://developer.berlios.de/projects/fullstory
###############################################################################
#	utility function to help with identifying device strings within strings
###############################################################################
fll_string_not_in_strings()
{
	VAR="${1}"
	shift

	for var in ${@}; do
		[ "${VAR}" = "${var}" ] && return 1
	done

	return 0
}
###############################################################################
# 	use information exported via proc and sysfs to make block device list
# 	bubble-sort cdrom devices to top of block device stack
###############################################################################
fll_finger_blockdevs()
{
	if [ "${FLL_FROMHD}" != "yes" ]; then
		#
		# cdrom detection via /proc/sys/dev/cdrom/info
		#
		if [ -f /proc/sys/dev/cdrom/info ]; then
			FLL_PROBED_CDROMS="$(awk '
				/name:/ {
					for (i = NF; i >= 3; i--) {
						print($i)
					}
				}
			' /proc/sys/dev/cdrom/info)"
		fi

		if [ "${FLL_PROBED_CDROMS}" ]; then
			for cdrom in ${FLL_PROBED_CDROMS}; do
				if [ -b "/dev/${cdrom}" ]; then
					echo "/dev/${cdrom}"
				fi
			done
		fi
	fi

	#
	# fromhd/fromiso/persist cheatcode required for additional block device detection
	#
	if [ "${FLL_FROMHD}" != "yes" ] && [ "${FLL_PERSIST}" != "yes" ]; then
		return 0
	fi

	#
	# generic block device detection
	#
	for dev in /sys/block/*; do
		dev=${dev#/sys/block/}
		
		case "${dev}" in
			#
			# skip ram, loop and floppy devices
			#
			ram[0-9]*|loop[0-9]*|fd[0-9]*)
				continue
				;;
		esac

		#
		# skip block devices already detected as cdroms
		#
		if [ "${FLL_PROBED_CDROMS}" ]; then
			if ! fll_string_not_in_strings "${dev}" ${FLL_PROBED_CDROMS}; then
				#
				# returned 1, already identified as cdrom device
				#
				continue
			fi
		fi
		
		#
		# use shell wildcard to expand subdevices
		#
		for subdev in $(echo /dev/${dev}*); do
			if [ -b "${subdev}" ]; then
				echo "${subdev}"
			fi
		done
	done
}
###############################################################################
# 	identify filesystem type of block device
###############################################################################
fll_finger_fstype()
{
	unset FSTYPE FSSIZE
	
	#
	# fstype from klibc-utils
	#
	eval $(fstype < ${1} 2>/dev/null)

	if ( [ -z "${FSTYPE}" ] || [ "${FSTYPE}" = "unknown" ] ) && \
		[ -x /lib/udev/vol_id ]; then
		FSTYPE=$(/lib/udev/vol_id -t ${1} 2>/dev/null)
	fi

	if [ "${FSTYPE}" ] && [ "${FSTYPE}" != "unknown" ]; then
		export FSTYPE
		export FSSIZE
		return 0
	fi
	
	return 1
}
###############################################################################
#	modprobe loop and wait for device node creation
###############################################################################
fll_setup_dev_loop()
{
	#
	# load loop device support
	#
	grep -q ^loop /proc/modules || modprobe "${MODPROBE_OPTIONS}" loop
	
	#
	# loop around for max of 5 seconds and wait for /dev/loop* device nodes
	#
	LOOP_WAIT="10"

	while [ "${LOOP_WAIT}" -gt 0 ]; do
		for l in /dev/loop*; do
			if [ -e "${l}" ]; then
				return 0
			fi
		done
		/bin/sleep 1
		LOOP_WAIT=$(( ${LOOP_WAIT} - 1 ))
	done

	panic "${R}Unable to setup loop mounted device, no loop device nodes exist${N}"

	#for n in 0 1 2 3 4 5 6 7; do
	#	mknod /dev/loop${n} b 7 ${n}
	#done
}
###############################################################################
#	generic mount function usage: fll_mount fs src mnt options
###############################################################################
fll_mount()
{
	FS="${1}"
	SRC="${2}"
	DST="${3}"
	shift 3

	#
	# default return value of 1, return 0 on successful mount
	#
	RETVAL=1
	
	case "${FS}" in
		iso9660|squashfs)
			if [ -f "${SRC}" ] && [ ! -b "${SRC}" ]; then
				fll_setup_dev_loop
				FLL_MOUNT_OPTS="ro,loop"
			else
				FLL_MOUNT_OPTS="ro"
			fi
			;;
		ntfs)
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@},dmask=0022,fmask=0133"
			else
				FLL_MOUNT_OPTS="ro,dmask=0022,fmask=0133"
			fi
			;;
		vfat)
			#
			# we need this for FLL_IMAGE on DOS-filesystems
			#
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@},shortname=winnt"
			else
				FLL_MOUNT_OPTS="shortname=winnt"
			fi
			;;
		suspend|swap|luks|lvm*)
			#
			# filesystem blacklist
			#
			return 1
			;;
		*)
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@}"
			fi
			;;
	esac

	if [ "${FLL_MOUNT_OPTS}" ]; then
		if mount -t ${FS} -o ${FLL_MOUNT_OPTS} ${SRC} ${DST} >/dev/null 2>&1; then
			RETVAL=0
		fi
	else
		if mount -t ${FS} ${SRC} ${DST} >/dev/null 2>&1; then
			RETVAL=0
		fi
	fi

	return "${RETVAL}"
}
###############################################################################
#	calculate total, used and unused memory: MEMTOTAL MEMUSED MEMFREE
###############################################################################
fll_meminfo()
{
	awk '
		/^MemTotal:/{
			total=$2
		}
		/^(MemFree|Buffers|Cached):/{
			free+=$2
		}
		END {
			printf("MEMTOTAL=%d\n",	int(total) / 1024)
			printf("MEMFREE=%d\n",	int(free) / 1024)
			printf("MEMUSED=%d\n",	(int(total) - int(free)) / 1024)
		}
	' /proc/meminfo
}
###############################################################################
#	utility function to display update when cp'ing live media into ram
###############################################################################
fll_copy_with_perc()
{
	if [ ! -f "${1}" ] || [ ! -d "${2}" ]; then
		return 1
	fi

	FLL_FILE_SIZE="$(du -s ${1} | awk '{ printf("%d\n", int($1)) }')"
	FLL_FILE_SIZE_COPY="0"
	
	#
	# background the copy, grab the process id
	#
	cp ${1} ${2} &
	FLL_FILE_COPY_PID="$!"

	#
	# update progress every second until cp finishes or files are of same size
	#
	printf "${Y}"
	while kill -0 "${FLL_FILE_COPY_PID}" 2>/dev/null && \
		[ "${FLL_FILE_SIZE_COPY}" -lt "${FLL_FILE_SIZE}" ]; do
		/bin/sleep 1
		if [ -f "${2}/${1##*/}" ]; then
			#
			# calculate and print the percentage of file copied so far
			#
			FLL_FILE_SIZE_COPY="$(du -s ${2}/${1##*/} | awk '{ printf("%d\n", int($1)) }')"
			awk 'BEGIN{ printf("\b\b\b%02d%s", 100 * '${FLL_FILE_SIZE_COPY}' / '${FLL_FILE_SIZE}', "%") }'
		else
			break
		fi
	done
	printf "${N}"

	if [ -f "${2}/${1##*/}" ]; then
		#
		# 3 second buffer before attempting to mount to avoid race condition with
		# mount that follows immediately after this function exits. Any value >=
		# to interval used in above loop should suffice.
		#
		/bin/sleep 3
		printf "\n"
		return 0
	fi

	return 1
}
###############################################################################
#	md5sum checker
###############################################################################
fll_md5sum_check()
{
	if [ ! -f "${1}/md5sums" ]; then
		printf "No md5sums file found on live media.\n"
		return 1
	fi

	awk -v dir=${1} '
		{
			sub(/^\*/, "", $2)
			
			md5 = $1
			file = $2

			printf("'${W}'")
			printf("* %s\n|--> %s\n`--> ", file, md5)
			printf("'${N}'")
			
			if(("md5sum " dir "/" file | getline) > 0) {
				if(md5 == $1) {
					printf("'${G}'")
					printf("%s  OK\n\n", $1)
					printf("'${N}'")
					next
				}
				else {
					printf("'${R}'")
					printf("%s  FAILED\n\n", $1)
					printf("'${N}'")
				}
			}
			else {
				printf("'${R}'")
				printf("Unable to calculate md5sum!\n\n")
				printf("'${N}'")
			}
			
			failed++
		}
		
		END{
			if(failed) {
				printf("'${R}'")
				printf("*******************************\n")
				printf("***** MD5SUM CHECK FAILED *****\n")
				printf("*******************************\n")
				printf("'${N}'")
				exit(1)
			}
			
			exit(0)
		}' "${1}/md5sums"
	
	return ${?}
}
###############################################################################
# 	define mountroot() for init
###############################################################################
mountroot()
{
	#
	# colourful escape sequences
	#
	N="[0;39m"	# Normal color
	R="[1;31m"	# Failure message
	G="[1;32m"	# Success message
	Y="[1;33m"	# Variable Descriptions
	W="[1;37m"	# Brackets
	
	#
	# force our arch string for i386
	#
	case "${DPKG_ARCH}" in
		i?86)
			FLL_ARCH="i686"
			;;
		*)
			FLL_ARCH="${DPKG_ARCH}"
			;;
	esac

	#
	# source distro-defaults
	#
	. /etc/default/distro
	
	#
	# parse fll options given on cmdline
	#
	for opt in $(cat /proc/cmdline); do
		case "${opt}" in
			fll=debug)
				set -x
				;;
			fll=verbose)
				FLL_VERBOSITY="yes"
				;;
			fll=init)
				FLL_LIVE_INITSCRIPTS="yes"
				;;
			fromhd*)
				FLL_FROMHD="yes"
				# define dev node
				case "${opt}" in
					fromhd=*)
						FLL_FROMHD_DEV="${opt#fromhd=}"
						;;
				esac
				;;
			fromiso*)
				FLL_FROMHD="yes"
				FLL_FROMISO="yes"
				# define iso name
				case "${opt}" in
					fromiso=*)
						FLL_MEDIA_NAME="${opt#fromiso=}"
						;;
				esac
				;;
			image_dir=*)
				FLL_IMAGE_DIR="${opt#image_dir=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			image_name=*)
				FLL_IMAGE_FILE="${opt#image_name=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			persist)
				FLL_PERSIST="yes"
				;;
			quiet)
				FLL_SUPPRESS_PRINTK="yes"
				;;
			testcd|testdvd|md5sum)
				FLL_MD5SUM_CHECK="yes"
				;;
			toram)
				FLL_TORAM="yes"
				;;
			unionfs|aufs)
				FLL_UNION_MODULE="${opt}"
				;;
		esac
	done

	#
	# disable kernel messages while mounting various filesystems
	#
	if [ "${FLL_SUPPRESS_PRINTK}" = "yes" ]; then
		echo "0" > /proc/sys/kernel/printk
	fi

	#
	# print geeky informational messages
	#
	printf "\n${W}Welcome to ${FLL_DISTRO_NAME} (${FLL_ARCH}) live linux${N}\n\n"

	#
	# Print kernel info
	#
	printf "${G}Linux Kernel\t${W}[ ${Y}$(uname -r)${W} ]${N}\n\n"

	#
	# Print CPU info
	#
	printf "${G}"
	awk -F: '
		/^processor/{
			printf("Processor'${Y}'"$2"'${G}' is\t")
		}
		/^model name/{
			gsub(/(\([Tt][Mm]\)|\([Rr]\))/,"",$2)
			gsub(/[ ]+/," ",$2)
			printf("'${W}'['${Y}'"$2"'${W}' ] ")
		}
		/^cpu MHz/{
			printf("[ '${Y}'%d MHz'${W}' ] ", int($2))
		}
		/^cache size/{
			printf("['${Y}'"$2" Cache'${W}' ]")
		}
		/^$/{
			printf("\n'${G}'")
		}
	' /proc/cpuinfo
	printf "${N}\n"

	#
	# Print System Memory info
	#
	eval $(fll_meminfo)
	printf "${G}System Memory\t${W}"
	printf "[ ${Y}${MEMUSED}M used ${W}] "
	printf "[ ${Y}${MEMFREE}M free${W} ] "
	printf "[ ${Y}${MEMTOTAL}M total${W} ]"
	printf "${N}\n\n"

	#
	# debug checkpoint
	#
	maybe_break fll-premount

	#
	# total time in seconds to do device scans for; rootdelay= on kernel cmdline
	# upper limit on how long we wait for devices to show up before bailing out
	#
	if [ "${ROOTDELAY}" ] && [ "${ROOTDELAY}" -gt 0 ]; then
		FLL_ROOTDELAY="${ROOTDELAY}"
	else
		FLL_ROOTDELAY="30"
	fi
	
	#
	# interval between device scans
	#
	FLL_MOUNT_INTERVAL="3"

	#
	# these variables are created during $FLL_ROOTDELAY time loop
	#
	unset FLL_BLOCKDEVS_OLD FLL_MOUNT_LOOP
	
	while [ "${FLL_ROOTDELAY}" -gt 0 ]; do
		#
		# refresh these for each loop
		#
		unset FLL_BLOCKDEVS FLL_BLOCKDEVS_NOW FLL_BLOCKDEVS_PROBED

		#
		# sleep time, we skip FLL_ROOTDELAY interval for first pass for extra fast boot
		#
		if [ "${FLL_MOUNT_LOOP}" ]; then
			if [ "${FLL_MOUNT_LOOP}" = 1 ]; then
				printf "${G}Waiting up to ${Y}${FLL_ROOTDELAY}${G}s for devices to settle${N}...\n"
			fi
			/bin/sleep "${FLL_MOUNT_INTERVAL}"
			FLL_ROOTDELAY=$(( ${FLL_ROOTDELAY} - ${FLL_MOUNT_INTERVAL} ))
		fi

		#
		# mount loop counter, it enforces sleep interval on next loop
		#
		FLL_MOUNT_LOOP=$(( ${FLL_MOUNT_LOOP} + 1 ))
		
		# XXX: ugly hack to allow booting in qemu
		if [ "${FLL_ROOTDELAY}" -le "${FLL_MOUNT_INTERVAL}" ]; then
			# only load me as last resort in case nothing helps.
			# Intel ICH7 and friends honour me with abysmal
			# performance.
			modprobe ide-generic
		fi
		
		#
		# determine block devices to be probed on this loop
		#
		if [ "${FLL_FROMHD_DEV}" ]; then
			#
			# user defined block device
			#
			FLL_BLOCKDEVS="${FLL_FROMHD_DEV}"
		else
			#
			# current list of block devices that may be probed for live media
			#
			FLL_BLOCKDEVS_NOW=$(fll_finger_blockdevs)
			#
			# FLL_BLOCKDEVS_OLD accounts for all devices probed so, it appends a copy of
			# FLL_BLOCKDEVS for every loop new devices are found
			# FLL_BLOCKDEVS is always a list of new devices that have not been probed so far
			#
			if [ "${FLL_BLOCKDEVS_OLD}" ]; then
				#
				# compare all devices probed so far with list of devices discovered now
				#
				for dev in ${FLL_BLOCKDEVS_NOW}; do
					if fll_string_not_in_strings ${dev} ${FLL_BLOCKDEVS_OLD}; then
						#
						# we have not yet probed these devices
						#
						FLL_BLOCKDEVS="${FLL_BLOCKDEVS} ${dev}"
					fi
				done
			else
				#
				# no devices probed so far, probe all that are currently detectable at this time
				#
				FLL_BLOCKDEVS="${FLL_BLOCKDEVS_NOW}"
			fi
		fi
	
		if [ -z "${FLL_BLOCKDEVS}" ]; then
			continue
		fi

		for dev in ${FLL_BLOCKDEVS}; do
			#
			# FLL_BLOCKMNT		- tracks current mount point
			#
			# FLL_DOUMOUNT		- stack of mount points to be umounted at end of
			#			  loop
			#
			# FLL_DOMOVEMOUNT	- stack of mount points to be move mounted if the
			#			  loop is broken
			#
			# FLL_MEDIA_FOUND	- set only when we have the live media compressed
			#			  filesystem located and mounted
			#
			unset FLL_BLOCKMNT FLL_DOUMOUNT FLL_DOMOVEMOUNT FLL_MEDIA_FOUND
		
			#
			# determine filesystem type of block device
			#
			if fll_finger_fstype "${dev}" >/dev/null 2>&1; then
				if [ -z "${FLL_BLOCKDEVS_PROBED}" ]; then
					printf "${G}Probing devices\t${N}"
				fi
				FLL_BLOCKDEVS_PROBED=$(( ${FLL_BLOCKDEVS_PROBED} + 1 ))
				printf "${W}[${Y} ${dev#/dev/}${W} ]${N} "
				#
				# we have determined FSTYPE of the device, set FLL_BLOCKMNT
				#
				FLL_BLOCKMNT="/fll/${dev#/dev/}"
				mkdir -p "${FLL_BLOCKMNT}"
				#
				# save origin of media in variable for persitency
				#
				if [ "${FLL_PERSIST}" = "yes" ]; then
					FLL_PERSIST_BLOCKDEV="${dev}"
					FLL_PERSIST_BLOCKFSTYPE="${FSTYPE}"
					FLL_PERSIST_BLOCKMNT="${FLL_BLOCKMNT}"
				fi
				#
				# mount block device on FLL_BLOCKMNT for probe
				#
				if fll_mount "${FSTYPE}" "${dev}" "${FLL_BLOCKMNT}" ro; then
					#
					# add current FLL_BLOCKMNT to FLL_DOMOVEMOUNT stack
					#
					FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
					#
					# probe for iso image
					#
					if [ "${FLL_FROMISO}" = "yes" ]; then
						if [ -f "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME#/}" ]; then
							#
							# located iso, update dev description
							#
							FLL_MEDIA_FOUND="${dev}"
							printf "\n\n"
							printf "${G}Detected ${Y}${FLL_MEDIA_NAME}${G} "
							printf "on ${Y}${FLL_MEDIA_FOUND}${G}.${N}\n"
							if fll_finger_fstype "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME}" >/dev/null 2>&1; then
								if [ "${FSTYPE}" != "iso9660" ]; then
									panic "${Y}${FLL_MEDIA_NAME}${R} not an iso9660 filesystem${N}"
								fi
								mkdir -p /fll/fromiso
								#
								# loop mount iso on FLL_MEDIA_MOUNTPOINT
								#	
								if fll_mount "${FSTYPE}" "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME}" /fll/fromiso; then
									if [ "${FLL_TORAM}" ]; then
										#
										# add block device mount point to umount stack
										#
										FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
									fi
									#
									# update FLL_BLOCKMNT, FLL_DOMOVEMOUNT stack, and dev description
									#
									FLL_BLOCKMNT="/fll/fromiso"
									FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
									dev="iso"
								else
									panic "${R}Failed to mount ${Y}${FSTYPE}${R} filesystem from iso image${N}"
								fi
							else
								panic "${R}Failed to identify filesystem type of iso${N}"
							fi
						fi
					fi
					#
					# probe for compressed filesystem
					#
					if [ -f "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" ]; then
						#
						# found FLL compressed filesystem
						# set/update FLL_MEDIA_FOUND variable (possibly already set via fromiso)
						#
						if [ "${FLL_MEDIA_FOUND}" ]; then
							printf "\n"
						else
							printf "\n\n"
						fi
						FLL_MEDIA_FOUND="${dev}"
						#
						# debug checkpoint
						#
						maybe_break fll-found
						#
						# md5sum check
						#
						if [ "${FLL_MD5SUM_CHECK}" = "yes" ]; then
							printf "${G}Performing ${Y}md5sum${G} integrity check of live media${N}...\n\n"
							if fll_md5sum_check ${FLL_BLOCKMNT}; then
								printf "${G}All md5sums verified successfully.${N}\n\n"
							else
								panic "${R}Failed md5sum check!${N}"
							fi
						fi
						#
						# prepare live filesystem
						#
						if fll_finger_fstype "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" >/dev/null 2>&1; then
							printf "${G}Detected live ${Y}${FSTYPE}${G} "
							printf "filesystem on ${Y}${FLL_MEDIA_FOUND}${N}\n"
							#
							# copy to tmpfs
							#
							if [ "${FLL_TORAM}" = "yes" ]; then
								#
								# required tmpfs size: compressed filesystem size + 10% buffer
								#
								eval $(fll_meminfo)
								FLL_TORAM_FSSIZE=$(du -s "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" | \
									awk '{ printf("%d\n", int($1 * 1.1 / 1024)) }')
								#
								# memory required to operate normally after iso has consumed memory
								# at least 32M is required
								#
								FLL_TORAM_MEMREQ=$(( ${FLL_TORAM_FSSIZE} + 32 ))
								#
								# do we have enough free memory for toram?
								#
								if [ "${MEMFREE}" -gt "${FLL_TORAM_MEMREQ}" ]; then
									#
									# prepare tmpfs, aka ramdisk
									#
									mkdir -p "/fll/toram"
									mount -n -t tmpfs -o size="${FLL_TORAM_FSSIZE}m" tmpfs "/fll/toram"
									mkdir -p "/fll/toram/${FLL_IMAGE_DIR}"
									#
									# copy compressed filesystem to tmpfs
									#
									printf "${G}Copying live filesystem from ${Y}${dev}${G} "
									printf "to ${Y}ram${G}:${N}    "
									if fll_copy_with_perc "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" "/fll/toram/${FLL_IMAGE_DIR}"; then
										#
										# add old mnt pnt to umount stack, update FLL_BLOCKMNT and dev
										#
										FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
										FLL_BLOCKMNT="/fll/toram"
										FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
										dev="ram"
									else
										if [ "${FLL_FROMISO}" = "yes" ]; then
											#
											# we failed to copy iso contents to ram: reset FLL_DOUMOUNT stack
											#
											unset FLL_DOUMOUNT
										fi
										#
										# umount the tmpfs or run-init will not be happy
										#
										FLL_DOUMOUNT="/fll/toram ${FLL_DOUMOUNT}"
										printf "${R}failed${N}\n"
										printf "\n${G}Continuing boot from live media${N}...\n"
									fi
								else
									printf "${R}Insufficient free memory to copy live media into memory${N}\n"
									printf "${R}Required free memory: ${Y}${FLL_TORAM_MEMREQ}M${N}\n"
									printf "\n${G}Continuing boot from live media${N}...\n"
									if [ "${FLL_FROMISO}" = "yes" ]; then
										#
										# we failed to copy iso contents to ram: reset FLL_DOUMOUNT stack
										#
										unset FLL_DOUMOUNT
									fi
								fi
							fi
							#
							# mount compressed filesystem, source directory: FLL_BLOCKMNT
							#
							mkdir -p "${FLL_MOUNTPOINT}"
							if fll_mount "${FSTYPE}" "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" "${FLL_MOUNTPOINT}"; then
								printf "${G}Mounted ${Y}${FSTYPE}${G} filesystem "
								printf "on ${Y}${FLL_MOUNTPOINT}${N}\n\n"
								FLL_DOMOVEMOUNT="${FLL_MOUNTPOINT} ${FLL_DOMOVEMOUNT}"
							else
								panic "${R}Failed to mount ${Y}${FSTYPE}${R} filesystem${N}"
							fi
						else
							panic "${R}Failed to identify filesystem type of live media image${N}"
						fi
					else
						#
						# probe next device, add current mount to FLL_DOUMOUNT stack
						#
						FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
					fi
				fi
			fi
		
			#
			# umount mount points in FLL_DOUMOUNT stack
			#
			for mnt in ${FLL_DOUMOUNT}; do
				umount "${mnt}" && rmdir "${mnt}"
			done
		
			#
			# break upon successful mount of live-media
			#
			if [ "${FLL_MEDIA_FOUND}" ]; then
				break 2
			fi
		done

		#
		# if we got here, we failed to find live media
		#
		
		#
		# keep account of what devices we have probed so far
		#
		FLL_BLOCKDEVS_OLD="${FLL_BLOCKDEVS_OLD} ${FLL_BLOCKDEVS}"
		
		#
		# start new probe line
		#
		printf "\n"
	done

	#
	# panic on failure to detect live media
	#
	if [ -z "${FLL_MEDIA_FOUND}" ]; then
		panic "${R}Failed to detect live media${N}"
	fi

	#
	# debug checkpoint
	#
	maybe_break fll-postmount

	#
	# mount a tmpfs over $rootmnt, reserving 10% system memory
	# Note: $rootmnt must be mounted with a fs != rootfs prior to run-init
	#
	printf "${G}Mounting virtual memory ${Y}tmpfs${G} filesystem on ${Y}${rootmnt}${G}${N}..."
	if mount -n -t tmpfs -o size=90%,mode=755 tmpfs "${rootmnt}"; then
		printf "\n"
	else
		panic "${R}Failed to mount tmpfs over ${Y}${rootmnt}${N}"
	fi

	#
	# move all mounts in FLL_DOMOVEMOUNT stack to $rootmnt
	#
	if [ "${FLL_DOMOVEMOUNT}" ]; then
		printf "${G}Moving all mounted filesystems to ${Y}${rootmnt}${G}${N}..."
		for mnt in ${FLL_DOMOVEMOUNT}; do
			if grep -q "${mnt}" /proc/mounts; then
				mkdir -p "${rootmnt}${mnt}"
				mount -n -o move "${mnt}" "${rootmnt}${mnt}"
			fi
		done
		printf "\n"
	fi
	
	#
	# sanity check, ${rootmnt}${FLL_MOUNTPOINT} _must_ exist
	#
	if [ ! -d "${rootmnt}${FLL_MOUNTPOINT}" ]; then
		panic "${R}Failed to find ${Y}${FLL_MOUNTPOINT}${G} on ${Y}${rootmnt}${N}"
	fi

	if [ -z "${FLL_UNION_MODULE}" ]; then
		FLL_UNION_MODULE="aufs"
	fi

	if modprobe "${MODPROBE_OPTIONS}" "${FLL_UNION_MODULE}"; then
		: # union filesystem support
	else
		panic "${R}Failed to load union filesystem support: ${Y}${FLL_UNION_MODULE}${N}"
	fi

	#
	# unioned filesystem mount points
	#
	FLL_UNION_MOUNTPOINT="/fll/${FLL_UNION_MODULE}"
	FLL_UNION_COWDIR="/fll/cow"

	#
	# prepare COW union filesystem, handle persistency
	#
	if [ "${FLL_PERSIST}" = "yes" ] && [ "${FLL_PERSIST_BLOCKMNT}" ]; then
		case "${FLL_PERSIST_BLOCKFSTYPE}" in
			ext*|reiser*|xfs|jfs)
				;;
			*)
				#
				# we could support vfat|msdos with a loop mounted ext* filesystem-in-a-file
				#
				panic "${R}Cannot create persistent filesystem with type ${Y}${FLL_PERSIST_BLOCKFSTYPE}${N}"
				;;
		esac
		#
		# FLL_PERSIST_BLOCKMNT points to position of mounted fielsystem before ot was moved
		# to the new root filesystem. Prepend ${rootmnt}.
		#
		FLL_UNION_COWMNTPNT="${rootmnt}${FLL_PERSIST_BLOCKMNT}"
		mkdir -p "${FLL_UNION_COWMNTPNT}"
		#
		# remount original fs containing live media rw (toram would umount it)
		#
		if grep -q "${FLL_UNION_COWMNTPNT}" /proc/mounts && mount -o remount,rw "${FLL_UNION_COWMNTPNT}" || \
			fll_mount ${FLL_PERSIST_BLOCKFSTYPE} ${FLL_PERSIST_BLOCKDEV} ${FLL_UNION_COWMNTPNT} rw; then
			printf "${G}Remounting persistent filesystem on ${Y}${FLL_PERSIST_BLOCKDEV}${G}${N}...\n"
		else
			panic "${R}Failed to remount persistent filesystem on ${Y}${FLL_PERSIST_DEV}${N}"
		fi
	else
		FLL_UNION_COWMNTPNT="${rootmnt}"
	fi
		
	mkdir -p "${rootmnt}${FLL_UNION_MOUNTPOINT}" "${FLL_UNION_COWMNTPNT}${FLL_UNION_COWDIR}"
	
	#
	# union module specific options
	#
	case "${FLL_UNION_MODULE}" in
		aufs)
			FLL_UNION_OPTIONS="br:${FLL_UNION_COWMNTPNT}${FLL_UNION_COWDIR}:${rootmnt}${FLL_MOUNTPOINT}"
			;;
		unionfs)
			FLL_UNION_OPTIONS="dirs=${FLL_UNION_COWMNTPNT}${FLL_UNION_COWDIR}=rw:${rootmnt}${FLL_MOUNTPOINT}=ro"
			;;
	esac
	
	#
	# mount the union COW filesystem
	#
	printf "${G}Mounting ${Y}${FLL_UNION_MODULE}${G} union filesystem${N}..."
	if mount -t "${FLL_UNION_MODULE}" -o "${FLL_UNION_OPTIONS}" "${FLL_UNION_MODULE}" "${rootmnt}${FLL_UNION_MOUNTPOINT}"; then
		printf "\n"
	else
		panic "${R}Failed to prepare ${Y}${FLL_UNION_MODULE}${R} union filesystem${N}"
	fi

	printf "${G}Preparing live filesystem on ${Y}${rootmnt}${G}${N}...\n"
	
	#
	# create links on $rootmnt to real filesystem
	#
	for dir in ${rootmnt}${FLL_UNION_MOUNTPOINT}/*; do
		if [ -d "${dir}" ]; then
			case "${dir##*/}" in
				dev|proc|sys|tmp)
					#
					# these should stay out of the unioned filesystem mount point
					# keep them directly on the ramdisk, they are handled below
					#
					continue
					;;
				*)
					#
					# link everything else to read-write unioned filesystem
					#
					if [ -L "${dir}" ]; then
						#
						# /lib64 -> /lib symlink handling
						#
						ln -sf "$(readlink -f ${dir})" "${rootmnt}/${dir##*/}"
					else
						#
						# bind mount links to read write union
						#
						mkdir -p "${rootmnt}/${dir##*/}"
						mount -n -o bind "${dir}" "${rootmnt}/${dir##*/}"
					fi
					;;
			esac
		fi
	done

	#
	# prepare /proc /sys
	#
	for dir in proc sys; do
		mkdir -p "${rootmnt}/${dir}"
	done

	#
	# tmp with correct permissions for users
	#
	mkdir -p -m 1777 "${rootmnt}/tmp"

	#
	# prepare /dev
	#
	mkdir -p -m 0755 "${rootmnt}/dev"

	printf "${G}Reconfiguring ${Y}sysvinit runlevels${G} for live boot${N}...\n"
	#
	# sanitise live SysV runlevel configuration
	#
	for rl in S 0 1 2 3 4 5 6; do
		[ -d ${rootmnt}/etc/rc${rl}.d/ ] || continue
		for s in ${rootmnt}/etc/rc${rl}.d/[SK][0-9][0-9]*; do
			[ -L "${s}" ] || continue
			case "${s##*/[SK][0-9][0-9]}" in
				fll-*)
					#
					# fll-live-initscripts
					#
					;;
				glibc.sh|bootmisc.sh|hostname.sh|mountkernfs.sh|mountdevsubfs.sh|keymap.sh|mtab.sh|console-screen.sh|umountnfs.sh)
					#
					# runlevel S .sh scripts, XXX: hwclock.sh
					#
					;;
				udev|module-init-tools|ifupdown-clean|fuse|networking|udev-mtab|ifupdown|x11-common|wpa-ifupdown|sendsigs|rmnologin)
					#
					# runlevel S scripts
					#
					;;
				acpid|alsa-utils|dbus|hal|avahi-daemon|powernowd|powersaved|hotkey-setup|gpm|bluetooth|pcmciautils|cupsys)
					#
					# default runlevel scripts and fll-live-initscripts managed services
					#
					;;
				*)
					#
					# purge everything else
					#
					rm -f "${s}"
					;;
			esac
		done
	done

	#
	# debug checkpoint
	#
	maybe_break fll-bottom

	#
	# disable movement of static $rootmnt/dev by scripts/init-bottom/udev
	#
	export no_static_dev="1"

	#
	# workaround cosmetic issue with selinux on live boot. It is doubtful that
	# anyone would find selinux a useful feature to have on an live-cd
	#
	export SELINUX_INIT=NO

	printf "\n${G}Starting ${Y}init${G} process${N}...\n\n"
}
###############################################################################
