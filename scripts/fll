#!/bin/sh

###############################################################################
#	F.U.L.L.S.T.O.R.Y initramfs live media init functions
#
#	Copyright:	(C) 2007 F.U.L.L.S.T.O.R.Y Project
#	License:	GPLv2
#
#	F.U.L.L.S.T.O.R.Y Project Homepage:
#	http://developer.berlios.de/projects/fullstory
###############################################################################
#	expand scope of PATH
###############################################################################
export PATH=/root/usr/bin:/root/usr/sbin:/root/bin:/root/sbin:/usr/bin:/usr/sbin:/bin:/sbin
###############################################################################
#	colourful escape sequences
###############################################################################
export NORMAL="[0;39m"	# NORMAL: Normal color
export RED="[1;31m"		# RED: Failure or error message
export GREEN="[1;32m"		# GREEN: Success message
export YELLOW="[1;33m"	# YELLOW: Descriptions
export BLUE="[1;34m"		# BLUE: System mesages
export MAGENTA="[1;35m"	# MAGENTA: Found devices or drivers
export CYAN="[1;36m"		# CYAN: Questions
export WHITE="[1;37m"		# BOLD WHITE: Hint
###############################################################################
#	force our arch string for i386
###############################################################################
case "${DPKG_ARCH}" in
	i?86)
		FLL_ARCH="i686"
		;;
	*)
		FLL_ARCH="${DPKG_ARCH}"
		;;
esac
export FLL_ARCH
###############################################################################
# 	parse /proc/cmdline for fll specific options
###############################################################################
fll_parse_cmdline()
{
	for opt in $(cat /proc/cmdline); do
		case "${opt}" in
			fll=*)
				case "${opt#fll=}" in
					debug)
						set -x
						;;
					verbose)
						FLL_VERBOSITY=1
						;;
				esac
				;;
			fromhd*)
				FLL_FROMHD="yes"
				;;
			fromiso*)
				FLL_FROMISO="yes"
				case "${opt}" in
					fromiso=*)
						# alternative to iso_dir=
						FLL_MEDIA_NAME="${opt#fromiso=}"
						;;
				esac
				;;
			image_dir=*)
				FLL_IMAGE_DIR="${opt#image_dir=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			image_name=*)
				FLL_IMAGE_FILE="${opt#image_name=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			iso_dir=*)
				FLL_MEDIA_DIR="${opt#iso_dir=}"
				;;
			iso_name=*)
				FLL_MEDIA_NAME="${opt#iso_name=}"
				;;
			toram)
				FLL_TORAM="yes"
				;;
			unionfs|aufs)
				if modprobe "${MODPROBE_OPTIONS}" "${opt}"; then
					FLL_UNION_MODULE="${opt}"
				fi
				;;
			union_opts=*)
				FLL_UNION_OPTIONS="${opt#union_opts=}"
				;;
		esac
	done
}
###############################################################################
# 	use information exported via proc and sysfs to make block device list
# 	bubble-sort cdrom devices to top of block device stack
###############################################################################
fll_finger_blockdevs()
{
	# cdrom detection via /proc/sys/dev/cdrom/info
	if [ -f /proc/sys/dev/cdrom/info ]; then
		probed_cdroms="$(awk '
			/name:/ {
				for (i = NF; i >= 3; i--) {
					print($i)
				}
			}
		' /proc/sys/dev/cdrom/info)"
	fi

	# give priority to cdrom devices
	if [ "${probed_cdroms}" ]; then
		for cdrom in ${probed_cdroms}; do
			if [ -b "/dev/${cdrom}" ]; then
				echo "/dev/${cdrom}"
			fi
		done
	fi

	# generic block device detection
	for dev in /sys/block/*; do
		dev=${dev#/sys/block/}
		
		case "${dev}" in
			# skip ram, loop and floppy devices
			ram[0-9]*|loop[0-9]*|fd[0-9]*)
				continue
				;;
		esac

		# skip block devices already detected as cdroms
		if [ "${probed_cdroms}" ]; then
			for cdrom in ${probed_cdroms}; do
				if [ "${cdrom}" = "${dev}" ]; then
					continue 2
				fi
			done
		fi

		# use shell wildcard to expand subdevices
		for subdev in $(echo /dev/${dev}*); do
			if [ -b "${subdev}" ]; then
				echo "${subdev}"
			fi
		done
	done
}
###############################################################################
# 	identify filesystem type of block device
###############################################################################
fll_finger_fstype()
{
	unset FSTYPE FSSIZE
	
	# fstype from klibc-utils
	eval $(fstype < ${1})

	if ( [ -z "${FSTYPE}" ] || [ "${FSTYPE}" = "unknown" ] ) && \
		[ -x /lib/udev/vol_id ]; then
		FSTYPE=$(/lib/udev/vol_id -t ${1})
	fi
	
	if [ "${FSTYPE}" ] && [ "${FSTYPE}" != "unknown" ]; then
		export FSTYPE
		export FSSIZE
		return 0
	fi
	
	return 1
}
###############################################################################
#	ugly hack to create "missing" /dev/loop{0..7} device nodes
###############################################################################
fll_setup_dev_loop()
{
	grep -q ^loop /proc/modules || modprobe "${MODPROBE_OPTIONS}" loop
	
	for n in 0 1 2 3 4 5 6 7; do
		[ -e /dev/loop${n} ] || mknod /dev/loop b${n} 7 ${n}
	done		
}
###############################################################################
#	generic mount function usage: fll_mount fs src mnt options
###############################################################################
fll_mount()
{
	FS="${1}"
	SRC="${2}"
	DST="${3}"
	shift 3
	
	case "${FS}" in
		squashfs|iso9660)
			if [ -f "${SRC}" ] && [ ! -b "${SRC}" ]; then
				fll_setup_dev_loop
				FLL_MOUNT_OPTS="ro,loop"
			else
				FLL_MOUNT_OPTS="ro"
			fi
			;;
		vfat)
			# We REALLY need this for FLL_IMAGE on DOS-filesystems
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@},shortname=winnt"
			else
				FLL_MOUNT_OPTS="shortname=winnt"
			fi
			;;
		*)
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@}"
			fi
			;;
	esac
	
	if [ "${FLL_MOUNT_OPTS}" ]; then
		if mount -t ${FS} -o ${FLL_MOUNT_OPTS} ${SRC} ${DST} >/dev/null 2>&1; then
			return 0
		fi
	else
		if mount -t ${FS} ${SRC} ${DST} >/dev/null 2>&1; then
			return 0
		fi
	fi

	return 1
}
###############################################################################
# 	define mountroot() for init
###############################################################################
mountroot()
{
	# source distro-defaults
	. /etc/default/distro
	
	# parse fll option on cmdline
	fll_parse_cmdline

	#######################################################################
	#	print geeky informational messages
	#######################################################################
	# Welcome message
	printf "\n${WHITE}Welcome to ${FLL_DISTRO_NAME} (${FLL_ARCH}) live linux!${NORMAL}\n\n"

	# Print kernel info
	printf "${GREEN}Linux Kernel\t${WHITE}[ ${YELLOW}$(uname -r)${WHITE} ]${NORMAL}\n\n"

	# Print CPU info
	printf "${GREEN}"
	awk -F: '
		/^processor/	{ printf("Processor'${YELLOW}'"$2"'${WHITE}'\t")	}
		/^model name/	{ printf("['${YELLOW}'"$2"'${WHITE}' ] ")		}
		/^cpu MHz/	{ printf("[ '${YELLOW}'%d MHz'${WHITE}' ] ", int($2))	}
		/^cache size/	{ printf("['${YELLOW}'"$2" Cache'${WHITE}' ]")		}
		/^$/		{ printf("\n'${GREEN}'")				}
	' /proc/cpuinfo
	printf "${NORMAL}\n"

	# Calculate total, used and unused memory: MEMTOTAL MEMUSED MEMFREE
	eval $(awk '
		/^MemTotal:/			{ total=$2 }
		/^(MemFree|Buffers|Cached):/	{ free+=$2 }
		END {
			printf("MEMTOTAL=%d\n",	int(total) / 1024)
			printf("MEMFREE=%d\n",	int(free) / 1024)
			printf("MEMUSED=%d\n",	(int(total) - int(free)) / 1024)
		}
	' /proc/meminfo)
	
	# Print System Memory info
	printf "${GREEN}System Memory\t${WHITE}"
	printf "[ ${YELLOW}${MEMUSED} M used ${WHITE}] "
	printf "[ ${YELLOW}${MEMFREE} M free${WHITE} ] "
	printf "[ ${YELLOW}${MEMTOTAL} M total${WHITE} ]"
	printf "${NORMAL}\n\n"

	#######################################################################
	#	find live-media
	#######################################################################
	# make live media temp FLL_IMAGE_LOCATION probe mountpoint
	mkdir -p /fll
	
	printf "${GREEN}Probing media\t${WHITE}[${YELLOW}"
	
	unset FLL_MEDIA_BD FLL_MEDIA_FS
	for dev in $(fll_finger_blockdevs); do
		if fll_finger_fstype "${dev}"; then
			printf " ${dev#/dev/}"
			if fll_mount "${FSTYPE}" "${dev}" /fll ro; then
				if [ -f "/fll/${FLL_IMAGE_LOCATION}" ]; then
					FLL_MEDIA_BD="${dev}"
					FLL_MEDIA_FS="${FSTYPE}"
					if fll_finger_fstype "/fll/${FLL_IMAGE_LOCATION}"; then
						if fll_mount "${FSTYPE}" "/fll/${FLL_IMAGE_LOCATION}" "${rootmnt}" ro; then
							break
						else
							unset FLL_MEDIA_BD FLL_MEDIA_FS
						fi
					else
						unset FLL_MEDIA_BD FLL_MEDIA_FS
					fi
				else
					# next please
					umount /fll
				fi
			fi
		fi
	done
	
	printf " ${WHITE}]${NORMAL}\n\n"

	if [ "${FLL_MEDIA_BD}" ]; then
		printf "${GREEN}Found media\t${WHITE}[ ${YELLOW}${FLL_MEDIA_BD}${WHITE} ]"
		printf " [ ${YELLOW}${FLL_MEDIA_FS}${WHITE} ]${NORMAL}\n\n"
	else
		printf "${RED}Failed to located live media!${NORMAL}\n\n"
	fi
}
###############################################################################
