#!/bin/sh

###############################################################################
#	F.U.L.L.S.T.O.R.Y initramfs live media init functions
#
#	Copyright:	(C) 2007 F.U.L.L.S.T.O.R.Y Project
#	License:	GPLv2
#
#	F.U.L.L.S.T.O.R.Y Project Homepage:
#	http://developer.berlios.de/projects/fullstory
###############################################################################
#	colourful escape sequences
###############################################################################
export NORMAL="[0;39m"	# NORMAL: Normal color
export BLUE="[1;34m"		# BLUE: System mesages
export RED="[1;31m"		# RED: Failure or error message
export GREEN="[1;32m"		# GREEN: Success message
export YELLOW="[1;33m"	# YELLOW: Descriptions
export WHITE="[1;37m"		# BOLD WHITE: Hint
###############################################################################
#	force our arch string for i386
###############################################################################
case "${DPKG_ARCH}" in
	i?86)
		FLL_ARCH="i686"
		;;
	*)
		FLL_ARCH="${DPKG_ARCH}"
		;;
esac
export FLL_ARCH
###############################################################################
# 	use information exported via proc and sysfs to make block device list
# 	bubble-sort cdrom devices to top of block device stack
###############################################################################
fll_finger_blockdevs()
{
	#
	# cdrom detection via /proc/sys/dev/cdrom/info
	#
	if [ -f /proc/sys/dev/cdrom/info ]; then
		FLL_PROBED_CDROMS="$(awk '
			/name:/ {
				for (i = NF; i >= 3; i--) {
					print($i)
				}
			}
		' /proc/sys/dev/cdrom/info)"
	fi

	#
	# give priority to cdrom devices, skip them for fromhd/fromiso
	#
	if [ "${FLL_PROBED_CDROMS}" ] && [ "${FLL_FROMHD}" != "yes" ]; then
		for cdrom in ${FLL_PROBED_CDROMS}; do
			if [ -b "/dev/${cdrom}" ]; then
				echo "/dev/${cdrom}"
			fi
		done
	fi

	#
	# fromhd/fromiso cheatcode required for additional block device detection
	#
	if [ "${FLL_FROMHD}" != "yes" ]; then
		return 0
	fi

	#
	# generic block device detection
	#
	for dev in /sys/block/*; do
		dev=${dev#/sys/block/}
		
		case "${dev}" in
			#
			# skip ram, loop and floppy devices
			#
			ram[0-9]*|loop[0-9]*|fd[0-9]*)
				continue
				;;
		esac

		#
		# skip block devices already detected as cdroms
		#
		if [ "${FLL_PROBED_CDROMS}" ]; then
			for cdrom in ${FLL_PROBED_CDROMS}; do
				if [ "${cdrom}" = "${dev}" ]; then
					continue 2
				fi
			done
		fi
		
		#
		# use shell wildcard to expand subdevices
		#
		for subdev in $(echo /dev/${dev}*); do
			if [ -b "${subdev}" ]; then
				echo "${subdev}"
			fi
		done
	done
}
###############################################################################
# 	identify filesystem type of block device
###############################################################################
fll_finger_fstype()
{
	unset FSTYPE FSSIZE
	
	#
	# fstype from klibc-utils
	#
	eval $(fstype < ${1} 2>/dev/null)

	if ( [ -z "${FSTYPE}" ] || [ "${FSTYPE}" = "unknown" ] ) && \
		[ -x /lib/udev/vol_id ]; then
		FSTYPE=$(/lib/udev/vol_id -t ${1} 2>/dev/null)
	fi

	if [ "${FSTYPE}" ] && [ "${FSTYPE}" != "unknown" ]; then
		export FSTYPE
		export FSSIZE
		return 0
	fi
	
	return 1
}
###############################################################################
#	modprobe loop and wait for device node creation
###############################################################################
fll_setup_dev_loop()
{
	#
	# load loop device support
	#
	grep -q ^loop /proc/modules || modprobe "${MODPROBE_OPTIONS}" loop
	
	#
	# loop around for max of 5 seconds and wait for /dev/loop* device nodes
	#
	LOOP_WAIT="10"

	while [ "${LOOP_WAIT}" -gt 0 ]; do
		for l in /dev/loop*; do
			if [ -e "${l}" ]; then
				return 0
			fi
		done
		/bin/sleep 1
		LOOP_WAIT=$(( ${LOOP_WAIT} - 1 ))
	done

	panic "${RED}Unable to setup loop mounted device, no loop device nodes exist${NORMAL}"

	#for n in 0 1 2 3 4 5 6 7; do
	#	mknod /dev/loop${n} b 7 ${n}
	#done
}
###############################################################################
#	generic mount function usage: fll_mount fs src mnt options
###############################################################################
fll_mount()
{
	FS="${1}"
	SRC="${2}"
	DST="${3}"
	shift 3

	#
	# default return value of 1, return 0 on successful mount
	#
	RETVAL=1
	
	case "${FS}" in
		iso9660|squashfs)
			if [ -f "${SRC}" ] && [ ! -b "${SRC}" ]; then
				fll_setup_dev_loop
				FLL_MOUNT_OPTS="ro,loop"
			else
				FLL_MOUNT_OPTS="ro"
			fi
			;;
		ntfs)
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@},dmask=0022,fmask=0133"
			else
				FLL_MOUNT_OPTS="ro,dmask=0022,fmask=0133"
			fi
			;;
		vfat)
			#
			# we need this for FLL_IMAGE on DOS-filesystems
			#
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@},shortname=winnt"
			else
				FLL_MOUNT_OPTS="shortname=winnt"
			fi
			;;
		suspend|swap|luks|lvm*)
			#
			# filesystem blacklist
			#
			return 1
			;;
		*)
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@}"
			fi
			;;
	esac

	if [ "${FLL_MOUNT_OPTS}" ]; then
		if mount -t ${FS} -o ${FLL_MOUNT_OPTS} ${SRC} ${DST} >/dev/null 2>&1; then
			RETVAL=0
		fi
	else
		if mount -t ${FS} ${SRC} ${DST} >/dev/null 2>&1; then
			RETVAL=0
		fi
	fi

	return "${RETVAL}"
}
###############################################################################
#	calculate total, used and unused memory: MEMTOTAL MEMUSED MEMFREE
###############################################################################
fll_meminfo()
{
	awk '
		/^MemTotal:/{
			total=$2
		}
		/^(MemFree|Buffers|Cached):/{
			free+=$2
		}
		END {
			printf("MEMTOTAL=%d\n",	int(total) / 1024)
			printf("MEMFREE=%d\n",	int(free) / 1024)
			printf("MEMUSED=%d\n",	(int(total) - int(free)) / 1024)
		}
	' /proc/meminfo
}
###############################################################################
#	utility function to help with identifying devices not yet probed
###############################################################################
fll_string_not_in_strings()
{
	VAR="${1}"
	shift

	for var in ${@}; do
		[ "${VAR}" = "${var}" ] && return 1
	done

	return 0
}
###############################################################################
#	utility function to display update when cp'ing live media into ram
###############################################################################
fll_copy_with_perc()
{
	if [ ! -f "${1}" ] || [ ! -d "${2}" ]; then
		return 1
	fi

	FLL_FILE_SIZE="$(du -s ${1} | awk '{ printf("%d\n", int($1)) }')"
	FLL_FILE_SIZE_COPY="0"
	
	#
	# background the copy, grab the process id
	#
	cp ${1} ${2} &
	FLL_FILE_COPY_PID="$!"

	#
	# update progress every second until cp finishes or files are of same size
	#
	printf "${YELLOW}"
	while kill -0 "${FLL_FILE_COPY_PID}" 2>/dev/null && \
		[ "${FLL_FILE_SIZE_COPY}" -lt "${FLL_FILE_SIZE}" ]; do
		/bin/sleep 1
		if [ -f "${2}/${1##*/}" ]; then
			#
			# calculate and print the percentage of file copied so far
			#
			FLL_FILE_SIZE_COPY="$(du -s ${2}/${1##*/} | awk '{ printf("%d\n", int($1)) }')"
			awk 'BEGIN{ printf("\b\b\b%02d%s", 100 * '${FLL_FILE_SIZE_COPY}' / '${FLL_FILE_SIZE}', "%") }'
		else
			break
		fi
	done
	printf "${NORMAL}"

	if [ -f "${2}/${1##*/}" ]; then
		#
		# 3 second buffer before attempting to mount to avoid race condition with
		# mount that follows immediately after this function exits. Any value >=
		# to interval used in above loop should suffice.
		#
		/bin/sleep 3
		printf "\n"
		return 0
	fi

	return 1
}
###############################################################################
#	md5sum checker
###############################################################################
fll_md5sum_check()
{
	if [ ! -f "${1}/md5sums" ]; then
		printf "No md5sums file found on live media.\n"
		return 1
	fi

	awk -v dir=${1} '
		{
			sub(/^\*/, "", $2)
			
			md5 = $1
			file = $2

			printf("'${YELLOW}'")
			printf("%s\n", file)
			printf("'${WHITE}'")
			printf("`--> ")
			printf("'${NORMAL}'")
			
			if(("md5sum " dir "/" file | getline) > 0) {
				if(md5 == $1) {
					printf("'${GREEN}'")
					printf("%s\n", $1)
					printf("'${NORMAL}'")
					next
				}
				else {
					printf("'${RED}'")
					printf("%s\n", $1)
					printf("'${NORMAL}'")
				}
			}
			else {
				printf("'${RED}'")
				printf("Unable to calculate md5sum!\n")
				printf("'${NORMAL}'")
			}

			printf("\n'${RED}'")
			printf("*******************************\n")
			printf("***** MD5SUM CHECK FAILED *****\n")
			printf("*******************************\n")
			printf("'${NORMAL}'")
			
			exit(1)
		}' "${1}/md5sums"
	
	return ${?}
}
###############################################################################
# 	define mountroot() for init
###############################################################################
mountroot()
{
	#
	# disable kernel messages while mounting various filesystems
	#
	echo "0" > /proc/sys/kernel/printk
	
	#
	# source distro-defaults
	#
	. /etc/default/distro
	
	#
	# parse fll options given on cmdline
	#
	for opt in $(cat /proc/cmdline); do
		case "${opt}" in
			fll=debug)
				set -x
				;;
			fll=verbose)
				FLL_VERBOSITY="yes"
				;;
			fromhd*)
				FLL_FROMHD="yes"
				# define dev node
				case "${opt}" in
					fromhd=*)
						FLL_FROMHD_DEV="${opt#fromhd=}"
						;;
				esac
				;;
			fromiso*)
				FLL_FROMHD="yes"
				FLL_FROMISO="yes"
				# define iso name
				case "${opt}" in
					fromiso=*)
						FLL_MEDIA_NAME="${opt#fromiso=}"
						;;
				esac
				;;
			image_dir=*)
				FLL_IMAGE_DIR="${opt#image_dir=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			image_name=*)
				FLL_IMAGE_FILE="${opt#image_name=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			persist)
				FLL_PERSIST="yes"
				#
				# persitency impossible from live-cd while FLL_FROMHD is set
				#
				FLL_FROMHD="yes"
				;;
			testcd|testdvd|md5sum)
				FLL_MD5SUM_CHECK="yes"
				;;
			toram)
				FLL_TORAM="yes"
				;;
			unionfs|aufs)
				FLL_UNION_MODULE="${opt}"
				;;
		esac
	done

	#
	# print geeky informational messages
	#
	printf "\n${WHITE}Welcome to ${FLL_DISTRO_NAME} (${FLL_ARCH}) live linux${NORMAL}\n\n"

	#
	# Print kernel info
	#
	printf "${GREEN}Linux Kernel\t${WHITE}[ ${YELLOW}$(uname -r)${WHITE} ]${NORMAL}\n\n"

	#
	# Print CPU info
	#
	printf "${GREEN}"
	awk -F: '
		/^processor/{
			printf("Processor'${YELLOW}'"$2"'${GREEN}' is\t")
		}
		/^model name/{
			gsub(/(\([Tt][Mm]\)|\([Rr]\))/,"",$2)
			gsub(/[ ]+/," ",$2)
			printf("'${WHITE}'['${YELLOW}'"$2"'${WHITE}' ] ")
		}
		/^cpu MHz/{
			printf("[ '${YELLOW}'%d MHz'${WHITE}' ] ", int($2))
		}
		/^cache size/{
			printf("['${YELLOW}'"$2" Cache'${WHITE}' ]")
		}
		/^$/{
			printf("\n'${GREEN}'")
		}
	' /proc/cpuinfo
	printf "${NORMAL}\n"

	#
	# Print System Memory info
	#
	eval $(fll_meminfo)
	printf "${GREEN}System Memory\t${WHITE}"
	printf "[ ${YELLOW}${MEMUSED}M used ${WHITE}] "
	printf "[ ${YELLOW}${MEMFREE}M free${WHITE} ] "
	printf "[ ${YELLOW}${MEMTOTAL}M total${WHITE} ]"
	printf "${NORMAL}\n\n"

	#
	# debug checkpoint
	#
	maybe_break fll-premount

	#
	# total time in seconds to do device scans for; rootdelay= on kernel cmdline
	# upper limit on how long we wait for devices to show up before bailing out
	#
	if [ "${ROOTDELAY}" ] && [ "${ROOTDELAY}" -gt 0 ]; then
		FLL_ROOTDELAY="${ROOTDELAY}"
	else
		FLL_ROOTDELAY="30"
	fi
	
	#
	# interval between device scans
	#
	FLL_MOUNT_INTERVAL="3"

	#
	# these variables are created during $FLL_ROOTDELAY time loop
	#
	unset FLL_BLOCKDEVS_OLD FLL_MOUNT_LOOP
	
	while [ "${FLL_ROOTDELAY}" -gt 0 ]; do
		#
		# refresh these for each loop
		#
		unset FLL_BLOCKDEVS FLL_BLOCKDEVS_NOW FLL_BLOCKDEVS_PROBED
		unset FLL_PERSIST_BLOCKDEV FLL_PERSIST_BLOCKFSTYPE FLL_PERSIST_BLOCKMNT

		#
		# sleep time, we skip FLL_ROOTDELAY interval for first pass for extra fast boot
		#
		if [ "${FLL_MOUNT_LOOP}" ]; then
			if [ "${FLL_MOUNT_LOOP}" = 1 ]; then
				printf "${GREEN}Waiting up to ${YELLOW}${FLL_ROOTDELAY}${GREEN}s for devices to settle...${NORMAL}\n"
			fi
			/bin/sleep "${FLL_MOUNT_INTERVAL}"
			FLL_ROOTDELAY=$(( ${FLL_ROOTDELAY} - ${FLL_MOUNT_INTERVAL} ))
		fi

		#
		# mount loop counter, it enforces sleep interval on next loop
		#
		FLL_MOUNT_LOOP=$(( ${FLL_MOUNT_LOOP} + 1 ))
		
		#
		# determine block devices to be probed on this loop
		#
		if [ "${FLL_FROMHD_DEV}" ]; then
			#
			# user defined block device
			#
			FLL_BLOCKDEVS="${FLL_FROMHD_DEV}"
		else
			#
			# current list of block devices that may be probed for live media
			#
			FLL_BLOCKDEVS_NOW=$(fll_finger_blockdevs)
			#
			# FLL_BLOCKDEVS_OLD accounts for all devices probed so, it appends a copy of
			# FLL_BLOCKDEVS for every loop new devices are found
			# FLL_BLOCKDEVS is always a list of new devices that have not been probed so far
			#
			if [ "${FLL_BLOCKDEVS_OLD}" ]; then
				#
				# compare all devices probed so far with list of devices discovered now
				#
				for dev in ${FLL_BLOCKDEVS_NOW}; do
					if fll_string_not_in_strings ${dev} ${FLL_BLOCKDEVS_OLD}; then
						#
						# we have not yet probed these devices
						#
						FLL_BLOCKDEVS="${FLL_BLOCKDEVS} ${dev}"
					fi
				done
			else
				#
				# no devices probed so far, probe all that are currently detectable at this time
				#
				FLL_BLOCKDEVS="${FLL_BLOCKDEVS_NOW}"
			fi
		fi
	
		if [ -z "${FLL_BLOCKDEVS}" ]; then
			continue
		fi

		for dev in ${FLL_BLOCKDEVS}; do
			#
			# FLL_BLOCKMNT		- tracks current mount point
			#
			# FLL_DOUMOUNT		- stack of mount points to be umounted at end of
			#			  loop
			#
			# FLL_DOMOVEMOUNT	- stack of mount points to be move mounted if the
			#			  loop is broken
			#
			# FLL_MEDIA_FOUND	- set only when we have the live media compressed
			#			  filesystem located and mounted
			#
			unset FLL_BLOCKMNT FLL_DOUMOUNT FLL_DOMOVEMOUNT FLL_MEDIA_FOUND
		
			#
			# determine filesystem type of block device
			#
			if fll_finger_fstype "${dev}" >/dev/null 2>&1; then
				if [ -z "${FLL_BLOCKDEVS_PROBED}" ]; then
					printf "${GREEN}Probing devices\t${NORMAL}"
				fi
				FLL_BLOCKDEVS_PROBED=$(( ${FLL_BLOCKDEVS_PROBED} + 1 ))
				printf "${WHITE}[${YELLOW} ${dev#/dev/}${WHITE} ]${NORMAL} "
				#
				# we have determined FSTYPE of the device, set FLL_BLOCKMNT
				#
				FLL_BLOCKMNT="/fll/${dev#/dev/}"
				mkdir -p "${FLL_BLOCKMNT}"
				#
				# save origin of media in variable for persitency
				#
				if [ "${FLL_PERSIST}" ]; then
					FLL_PERSIST_BLOCKDEV="${dev}"
					FLL_PERSIST_BLOCKFSTYPE="${FSTYPE}"
					FLL_PERSIST_BLOCKMNT="${FLL_BLOCKMNT}"
				fi
				#
				# mount block device on FLL_BLOCKMNT for probe
				#
				if fll_mount "${FSTYPE}" "${dev}" "${FLL_BLOCKMNT}" ro; then
					#
					# add current FLL_BLOCKMNT to FLL_DOMOVEMOUNT stack
					#
					FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
					#
					# probe for iso image
					#
					if [ "${FLL_FROMISO}" = "yes" ]; then
						if [ -f "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME#/}" ]; then
							#
							# located iso, update dev description
							#
							FLL_MEDIA_FOUND="${dev}"
							printf "\n\n"
							printf "${GREEN}Detected ${YELLOW}${FLL_MEDIA_NAME}${GREEN} "
							printf "on ${YELLOW}${FLL_MEDIA_FOUND}${GREEN}.${NORMAL}\n"
							if fll_finger_fstype "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME}" >/dev/null 2>&1; then
								if [ "${FSTYPE}" != "iso9660" ]; then
									panic "${YELLOW}${FLL_MEDIA_NAME}${RED} not an iso9660 filesystem${NORMAL}"
								fi
								mkdir -p /fll/fromiso
								#
								# loop mount iso on FLL_MEDIA_MOUNTPOINT
								#	
								if fll_mount "${FSTYPE}" "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME}" /fll/fromiso; then
									if [ "${FLL_TORAM}" ]; then
										#
										# add block device mount point to umount stack
										#
										FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
									fi
									#
									# update FLL_BLOCKMNT, FLL_DOMOVEMOUNT stack, and dev description
									#
									FLL_BLOCKMNT="/fll/fromiso"
									FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
									dev="iso"
								else
									panic "${RED}Failed to mount ${YELLOW}${FSTYPE}${RED} filesystem from iso image${NORMAL}"
								fi
							else
								panic "${RED}Failed to identify filesystem type of iso${NORMAL}"
							fi
						fi
					fi
					#
					# probe for compressed filesystem
					#
					if [ -f "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" ]; then
						#
						# found FLL compressed filesystem
						# set/update FLL_MEDIA_FOUND variable (possibly already set via fromiso)
						#
						if [ "${FLL_MEDIA_FOUND}" ]; then
							printf "\n"
						else
							printf "\n\n"
						fi
						FLL_MEDIA_FOUND="${dev}"
						#
						# debug checkpoint
						#
						maybe_break fll-found
						#
						# md5sum check
						#
						if [ "${FLL_MD5SUM_CHECK}" ]; then
							printf "${GREEN}Performing ${YELLOW}md5sum${GREEN} integrity check of live media...${NORMAL}\n"
							if fll_md5sum_check ${FLL_BLOCKMNT}; then
								printf "${GREEN}All md5sums verified successfully.${NORMAL}\n\n"
							else
								panic "${RED}Failed md5sum check!${NORMAL}"
							fi
						fi
						#
						# prepare live filesystem
						#
						if fll_finger_fstype "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" >/dev/null 2>&1; then
							printf "${GREEN}Detected live ${YELLOW}${FSTYPE}${GREEN} "
							printf "filesystem on ${YELLOW}${FLL_MEDIA_FOUND}${NORMAL}\n"
							#
							# copy to tmpfs
							#
							if [ "${FLL_TORAM}" ]; then
								#
								# required tmpfs size: compressed filesystem size + 10% buffer
								#
								eval $(fll_meminfo)
								FLL_TORAM_FSSIZE=$(du -s "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" | \
									awk '{ printf("%d\n", int($1 * 1.1 / 1024)) }')
								#
								# memory required to operate normally after iso has consumed memory
								# at least 32M is required
								#
								FLL_TORAM_MEMREQ=$(( ${FLL_TORAM_FSSIZE} + 32 ))
								#
								# do we have enough free memory for toram?
								#
								if [ "${MEMFREE}" -gt "${FLL_TORAM_MEMREQ}" ]; then
									#
									# prepare tmpfs, aka ramdisk
									#
									mkdir -p "/fll/toram"
									mount -n -t tmpfs -o size="${FLL_TORAM_FSSIZE}m" tmpfs "/fll/toram"
									mkdir -p "/fll/toram/${FLL_IMAGE_DIR}"
									#
									# copy compressed filesystem to tmpfs
									#
									printf "${GREEN}Copying live filesystem from ${YELLOW}${dev}${GREEN} "
									printf "to ${YELLOW}ram${GREEN}:${NORMAL}    "
									if fll_copy_with_perc "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" "/fll/toram/${FLL_IMAGE_DIR}"; then
										#
										# add old mnt pnt to umount stack, update FLL_BLOCKMNT and dev
										#
										FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
										FLL_BLOCKMNT="/fll/toram"
										FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
										dev="ram"
									else
										if [ "${FLL_FROMISO}" = "yes" ]; then
											#
											# we failed to copy iso contents to ram: reset FLL_DOUMOUNT stack
											#
											unset FLL_DOUMOUNT
										fi
										#
										# umount the tmpfs or run-init will not be happy
										#
										FLL_DOUMOUNT="/fll/toram ${FLL_DOUMOUNT}"
										printf "${RED}failed${NORMAL}\n"
									fi
								else
									printf "${RED}Insufficient free memory to copy live media into memory${NORMAL}\n"
									printf "${RED}Required free memory: ${YELLOW}${FLL_TORAM_MEMREQ}M${NORMAL}\n"
									if [ "${FLL_FROMISO}" = "yes" ]; then
										#
										# we failed to copy iso contents to ram: reset FLL_DOUMOUNT stack
										#
										unset FLL_DOUMOUNT
									fi
								fi
							fi
							#
							# mount compressed filesystem, source directory: FLL_BLOCKMNT
							#
							mkdir -p "${FLL_MOUNTPOINT}"
							if fll_mount "${FSTYPE}" "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" "${FLL_MOUNTPOINT}"; then
								printf "${GREEN}Mounted ${YELLOW}${FSTYPE}${GREEN} filesystem "
								printf "on ${YELLOW}${FLL_MOUNTPOINT}${NORMAL}\n\n"
								FLL_DOMOVEMOUNT="${FLL_MOUNTPOINT} ${FLL_DOMOVEMOUNT}"
							else
								panic "${RED}Failed to mount ${YELLOW}${FSTYPE}${RED} filesystem${NORMAL}"
							fi
						else
							panic "${RED}Failed to identify filesystem type of live media image${NORMAL}"
						fi
					else
						#
						# probe next device, add current mount to FLL_DOUMOUNT stack
						#
						FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
					fi
				fi
			fi
		
			#
			# umount mount points in FLL_DOUMOUNT stack
			#
			for mnt in ${FLL_DOUMOUNT}; do
				umount "${mnt}" && rmdir "${mnt}"
			done
		
			#
			# break upon successful mount of live-media
			#
			if [ "${FLL_MEDIA_FOUND}" ]; then
				break 2
			fi
		done

		#
		# if we got here, we failed to find live media
		#
		
		#
		# keep account of what devices we have probed so far
		#
		FLL_BLOCKDEVS_OLD="${FLL_BLOCKDEVS_OLD} ${FLL_BLOCKDEVS}"
		
		#
		# start new probe line
		#
		printf "\n"
	done

	#
	# panic on failure to detect live media
	#
	if [ -z "${FLL_MEDIA_FOUND}" ]; then
		panic "${RED}Failed to detect live media${NORMAL}"
	fi

	#
	# debug checkpoint
	#
	maybe_break fll-postmount

	#
	# mount a tmpfs over $rootmnt, reserving 10% system memory
	# Note: $rootmnt must be mounted with a fs != rootfs prior to run-init
	#
	printf "${GREEN}Mounting virtual memory ${YELLOW}tmpfs${GREEN} filesystem on ${YELLOW}${rootmnt}${GREEN}...${NORMAL}"
	if mount -n -t tmpfs -o size=90%,mode=755 tmpfs "${rootmnt}"; then
		printf "\n"
	else
		panic "${RED}Failed to mount tmpfs over ${YELLOW}${rootmnt}${NORMAL}"
	fi

	#
	# move all mounts in FLL_DOMOVEMOUNT stack to $rootmnt
	#
	if [ "${FLL_DOMOVEMOUNT}" ]; then
		printf "${GREEN}Moving all mounted filesystems to ${YELLOW}${rootmnt}${GREEN}...${NORMAL}"
		for mnt in ${FLL_DOMOVEMOUNT}; do
			if grep -q "${mnt}" /proc/mounts; then
				mkdir -p "${rootmnt}${mnt}"
				mount -n -o move "${mnt}" "${rootmnt}${mnt}"
			fi
		done
		printf "\n"
	fi
	
	#
	# sanity check, ${rootmnt}${FLL_MOUNTPOINT} _must_ exist
	#
	if [ ! -d "${rootmnt}${FLL_MOUNTPOINT}" ]; then
		panic "${RED}Failed to find ${YELLOW}${FLL_MOUNTPOINT}${GREEN} on ${YELLOW}${rootmnt}${NORMAL}"
	fi

	if [ -z "${FLL_UNION_MODULE}" ]; then
		FLL_UNION_MODULE="aufs"
	fi

	if modprobe "${MODPROBE_OPTIONS}" "${FLL_UNION_MODULE}"; then
		: # union filesystem support
	else
		panic "${RED}Failed to load union filesystem support: ${YELLOW}${FLL_UNION_MODULE}${NORMAL}"
	fi

	#
	# fallback definitions, these are in distro-defaults
	#
	if [ -z "${FLL_UNION_MOUNTPOINT}" ]; then
		FLL_UNION_MOUNTPOINT="/UNIONFS"
	fi
	if [ -z "${FLL_UNION_COWDIR}" ]; then
		FLL_UNION_COWDIR="/COW"
	fi

	#
	# prepare COW union filesystem, handle persistency
	#
	if [ "$FLL_PERSIST" ]; then
		FLL_UNION_COWMNTPNT="${rootmnt}${FLL_PERSIST_MOUNTBLK}"
		mkdir -p "${rootmnt}${FLL_PERSIST_MOUNTBLK}"
		#
		# remount original fs containing live media rw (toram would umount it)
		# XXX: sanity checking of target filesystem required
		#
		if mount -o remount,rw "${FLL_UNION_COWMNTPNT}" || \
			fll_mount ${FLL_PERSIST_MOUNTFSTYPE} ${FLL_PERSIST_MOUNTDEV} ${FLL_UNION_COWMNTPNT} rw; then
			printf "${GREEN}Remounting persistent filesystem ${YELLOW}${FLL_PERSIST_DEV}${FLL_UNION_COWDIR}${GREEN}...${NORMAL}"
		else
			panic "${RED}Failed to remount persistent filesystem ${YELLOW}${FLL_PERSIST_DEV}${FLL_UNION_COWDIR}${NORMAL}"
		fi
		#
		# XXX: need to handle loop mounted filesystems for non *nix filesystems
		#
	else
		FLL_UNION_COWMNTPNT="${rootmnt}"
	fi
		
	mkdir -p "${rootmnt}${FLL_UNION_MOUNTPOINT}" "${FLL_UNION_COWMNTPNT}${FLL_UNION_COWDIR}"
	#
	# union module specific options
	#
	case "${FLL_UNION_MODULE}" in
		aufs)
			FLL_UNION_OPTIONS="br:${FLL_UNION_COWMNTPNT}${FLL_UNION_COWDIR}:${rootmnt}${FLL_MOUNTPOINT}"
			;;
		unionfs)
			FLL_UNION_OPTIONS="dirs=${FLL_UNION_COWMNTPNT}${FLL_UNION_COWDIR}=rw:${rootmnt}${FLL_MOUNTPOINT}=ro"
			;;
	esac
	#
	# mount the union COW filesystem
	#
	printf "${GREEN}Mounting ${YELLOW}${FLL_UNION_MODULE}${GREEN} union filesystem...${NORMAL}"
	if mount -t "${FLL_UNION_MODULE}" -o "${FLL_UNION_OPTIONS}" "${FLL_UNION_MODULE}" "${rootmnt}${FLL_UNION_MOUNTPOINT}"; then
		printf "\n"
	else
		panic "${RED}Failed to prepare ${YELLOW}${FLL_UNION_MODULE}${RED} union filesystem${NORMAL}"
	fi

	printf "${GREEN}Preparing live filesystem on ${YELLOW}${rootmnt}${GREEN}...${NORMAL}\n"
	
	#
	# create links on $rootmnt to real filesystem
	#
	for dir in ${rootmnt}${FLL_UNION_MOUNTPOINT}/*; do
		if [ -d "${dir}" ]; then
			case "${dir##*/}" in
				dev|proc|sys|tmp)
					#
					# these should stay out of the unioned filesystem mount point
					# keep them directly on the ramdisk, they are handled below
					#
					continue
					;;
				*)
					#
					# link everything else to read-write unioned filesystem
					#
					if [ -L "${dir}" ]; then
						#
						# /lib64 -> /lib symlink handling
						#
						ln -sf "$(readlink -f ${dir})" "${rootmnt}/${dir##*/}"
					else
						#
						# bind mount links to read write union
						#
						mkdir -p "${rootmnt}/${dir##*/}"
						mount -n -o bind "${dir}" "${rootmnt}/${dir##*/}"
					fi
					;;
			esac
		fi
	done

	#
	# prepare /proc /sys
	#
	for dir in proc sys; do
		mkdir -p "${rootmnt}/${dir}"
	done

	#
	# tmp with correct permissions for users
	#
	mkdir -p -m 1777 "${rootmnt}/tmp"

	#
	# prepare /dev
	# Note: disable movement of static $rootmnt/dev by scripts/init-bottom/udev
	#
	mkdir -p -m 0755 "${rootmnt}/dev"
	export no_static_dev="1"

	#
	# purge /etc/rc?.d/ for live boot
	#
	for dir in ${rootmnt}/etc/rc*.d; do
		if [ -d "${dir}" ]; then
			rm -rf "${dir}" && mkdir -p "${dir}"
		fi
	done
	
	#
	# link up initscripts-$distro-live
	#
	ln -sf ../init.d/live-autoconfig	"${rootmnt}/etc/rcS.d/S00live-autoconfig"
	ln -sf ../init.d/live-halt		"${rootmnt}/etc/rc0.d/S90live-halt"
	ln -sf ../init.d/live-reboot		"${rootmnt}/etc/rc6.d/S90live-reboot"

	#
	# debug checkpoint
	#
	maybe_break fll-bottom

	printf "\n${GREEN}Starting init process...${NORMAL}\n\n"
}
###############################################################################
