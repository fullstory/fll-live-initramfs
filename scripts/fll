#!/bin/sh

###############################################################################
#	F.U.L.L.S.T.O.R.Y initramfs live media init functions
#
#	Copyright:	(C) 2007 F.U.L.L.S.T.O.R.Y Project
#	License:	GPLv2
#
#	F.U.L.L.S.T.O.R.Y Project Homepage:
#	http://developer.berlios.de/projects/fullstory
###############################################################################
#	colourful escape sequences
###############################################################################
export NORMAL="[0;39m"	# NORMAL: Normal color
export BLUE="[1;34m"		# BLUE: System mesages
export RED="[1;31m"		# RED: Failure or error message
export GREEN="[1;32m"		# GREEN: Success message
export YELLOW="[1;33m"	# YELLOW: Descriptions
export WHITE="[1;37m"		# BOLD WHITE: Hint
###############################################################################
#	force our arch string for i386
###############################################################################
case "${DPKG_ARCH}" in
	i?86)
		FLL_ARCH="i686"
		;;
	*)
		FLL_ARCH="${DPKG_ARCH}"
		;;
esac
export FLL_ARCH
###############################################################################
# 	parse /proc/cmdline for fll specific options
###############################################################################
fll_parse_cmdline()
{
	for opt in $(cat /proc/cmdline); do
		case "${opt}" in
			fll=debug)
				set -x
				;;
			fll_interval=*)
				FLL_MOUNT_INTERVAL="${opt#fll_interval=}"
				;;
			fromhd*)
				FLL_FROMHD="yes"
				# define dev node
				case "${opt}" in
					fromhd=*)
						FLL_FROMHD_DEV="${opt#fromhd=}"
						;;
				esac
				;;
			fromiso*)
				FLL_FROMHD="yes"
				FLL_FROMISO="yes"
				# define iso name
				case "${opt}" in
					fromiso=*)
						FLL_MEDIA_NAME="${opt#fromiso=}"
						;;
				esac
				;;
			image_dir=*)
				FLL_IMAGE_DIR="${opt#image_dir=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			image_name=*)
				FLL_IMAGE_FILE="${opt#image_name=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			toram)
				FLL_TORAM="yes"
				;;
			unionfs|aufs)
				if modprobe "${MODPROBE_OPTIONS}" "${opt}"; then
					FLL_UNION_MODULE="${opt}"
				fi
				;;
		esac
	done
}
###############################################################################
# 	use information exported via proc and sysfs to make block device list
# 	bubble-sort cdrom devices to top of block device stack
###############################################################################
fll_finger_blockdevs()
{
	# cdrom detection via /proc/sys/dev/cdrom/info
	if [ -f /proc/sys/dev/cdrom/info ]; then
		probed_cdroms="$(awk '
			/name:/ {
				for (i = NF; i >= 3; i--) {
					print($i)
				}
			}
		' /proc/sys/dev/cdrom/info)"
	fi

	# give priority to cdrom devices, skip them for fromhd/fromiso
	if [ "${probed_cdroms}" ] && [ "${FLL_FROMHD}" != "yes" ]; then
		for cdrom in ${probed_cdroms}; do
			if [ -b "/dev/${cdrom}" ]; then
				echo "/dev/${cdrom}"
			fi
		done
	fi

	#
	# fromhd/fromiso cheatcode required for additional block device detection
	#
	if [ "${FLL_FROMHD}" != "yes" ]; then
		return 0
	fi

	# generic block device detection
	for dev in /sys/block/*; do
		dev=${dev#/sys/block/}
		
		case "${dev}" in
			# skip ram, loop and floppy devices
			ram[0-9]*|loop[0-9]*|fd[0-9]*)
				continue
				;;
		esac

		# skip block devices already detected as cdroms
		if [ "${probed_cdroms}" ]; then
			for cdrom in ${probed_cdroms}; do
				if [ "${cdrom}" = "${dev}" ]; then
					continue 2
				fi
			done
		fi

		# use shell wildcard to expand subdevices
		for subdev in $(echo /dev/${dev}*); do
			if [ -b "${subdev}" ]; then
				echo "${subdev}"
			fi
		done
	done
}
###############################################################################
# 	identify filesystem type of block device
###############################################################################
fll_finger_fstype()
{
	unset FSTYPE FSSIZE
	
	# fstype from klibc-utils
	eval $(fstype < ${1} 2>/dev/null)

	if [ "${FSTYPE}" ] && [ "${FSTYPE}" != "unknown" ]; then
		export FSTYPE
		export FSSIZE
		return 0
	fi
	
	return 1
}
###############################################################################
#	modprobe loop and wait for device node creation
###############################################################################
fll_setup_dev_loop()
{
	grep -q ^loop /proc/modules || modprobe "${MODPROBE_OPTIONS}" loop
	
	loop_wait="5"
	loop_ready="no"
	#
	# loop around for max of 5 seconds and wait for /dev/loop* device nodes
	#	
	while [ "${loop_wait}" -gt 0 ]; do
		for l in /dev/loop*; do
			if [ -e "${l}" ]; then
				loop_ready="yes"
				break 2
			fi
		done
		/bin/sleep 1
		loop_wait=$(( ${loop_wait} - 1 ))
	done

	if [ "${loop_ready}" = "yes" ]; then
		return 0
	fi

	panic "${RED}Unable to setup loop mounted device, no loop device nodes exist${NORMAL}"
	
	#
	# ugly hack to create "missing" /dev/loop{0..7} device nodes
	#
	#for n in 0 1 2 3 4 5 6 7; do
	#	mknod /dev/loop${n} b 7 ${n}
	#done
}
###############################################################################
#	generic mount function usage: fll_mount fs src mnt options
###############################################################################
fll_mount()
{
	FS="${1}"
	SRC="${2}"
	DST="${3}"
	shift 3

	# default return value of 1, return 0 on successful mount
	RETVAL=1
	
	case "${FS}" in
		iso9660|squashfs)
			if [ -f "${SRC}" ] && [ ! -b "${SRC}" ]; then
				fll_setup_dev_loop
				FLL_MOUNT_OPTS="ro,loop"
			else
				FLL_MOUNT_OPTS="ro"
			fi
			;;
		ntfs)
			# uid + gid of 1000: may not be true in some cases
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@},uid=1000,gid=1000"
			else
				FLL_MOUNT_OPTS="ro,uid=1000,gid=1000"
			fi
			;;
		vfat)
			# we need this for FLL_IMAGE on DOS-filesystems
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@},shortname=winnt"
			else
				FLL_MOUNT_OPTS="shortname=winnt"
			fi
			;;
		suspend|swap|luks|lvm*)
			#
			# filesystem blacklist
			#
			return 1
			;;
		*)
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@}"
			fi
			;;
	esac

	# disable kernel messages while mounting various filesystems
	echo "0" > /proc/sys/kernel/printk
	
	if [ "${FLL_MOUNT_OPTS}" ]; then
		if mount -t ${FS} -o ${FLL_MOUNT_OPTS} ${SRC} ${DST} >/dev/null 2>&1; then
			RETVAL=0
		fi
	else
		if mount -t ${FS} ${SRC} ${DST} >/dev/null 2>&1; then
			RETVAL=0
		fi
	fi

	# re-enable kernel messages
	echo "6" > /proc/sys/kernel/printk

	return "${RETVAL}"
}
###############################################################################
#	Calculate total, used and unused memory: MEMTOTAL MEMUSED MEMFREE
###############################################################################
fll_meminfo()
{
	awk '
		/^MemTotal:/			{ total=$2 }
		/^(MemFree|Buffers|Cached):/	{ free+=$2 }
		END {
			printf("MEMTOTAL=%d\n",	int(total) / 1024)
			printf("MEMFREE=%d\n",	int(free) / 1024)
			printf("MEMUSED=%d\n",	(int(total) - int(free)) / 1024)
		}
	' /proc/meminfo
}
###############################################################################
# 	define mountroot() for init
###############################################################################
mountroot()
{
	# source distro-defaults
	. /etc/default/distro
	
	# parse fll option on cmdline
	fll_parse_cmdline

	#
	# print geeky informational messages
	#
	printf "\n${WHITE}Welcome to ${FLL_DISTRO_NAME} (${FLL_ARCH}) live linux${NORMAL}\n\n"

	#
	# Print kernel info
	#
	printf "${GREEN}Linux Kernel\t${WHITE}[ ${YELLOW}$(uname -r)${WHITE} ]${NORMAL}\n\n"

	#
	# Print CPU info
	#
	printf "${GREEN}"
	awk -F: '
		/^processor/	{ printf("Processor'${YELLOW}'"$2"'${GREEN}' is\t")	}
		/^model name/	{ printf("'${WHITE}'['${YELLOW}'"$2"'${WHITE}' ] ")	}
		/^cpu MHz/	{ printf("[ '${YELLOW}'%d MHz'${WHITE}' ] ", int($2))	}
		/^cache size/	{ printf("['${YELLOW}'"$2" Cache'${WHITE}' ]")		}
		/^$/		{ printf("\n'${GREEN}'")				}
	' /proc/cpuinfo
	printf "${NORMAL}\n"

	#
	# Print System Memory info
	#
	eval $(fll_meminfo)
	printf "${GREEN}System Memory\t${WHITE}"
	printf "[ ${YELLOW}${MEMUSED}M used ${WHITE}] "
	printf "[ ${YELLOW}${MEMFREE}M free${WHITE} ] "
	printf "[ ${YELLOW}${MEMTOTAL}M total${WHITE} ]"
	printf "${NORMAL}\n\n"

	#
	# debug checkpoint
	#
	maybe_break fll-premount

	#
	# total time in seconds to do device scans for; rootdelay= on kernel cmdline
	# upper limit on how long we wait for devices to show up before bailing out
	#
	if [ "${ROOTDELAY}" ]; then
		if [ "${ROOTDELAY}" -gt 0 ]; then
			slumber="${ROOTDELAY}"
		fi
	else
		slumber="30"
	fi
	
	#
	# time between device scans; fll_interval= on kernel cmdline
	#
	if [ "${FLL_MOUNT_INTERVAL}" ]; then
		#
		# user defined interval between now and initial device scan loop
		#
		if [ "${FLL_MOUNT_INTERVAL}" -gt 0 ]; then
			interval="${FLL_MOUNT_INTERVAL}"
		fi
	else
		#
		# default interval between device scan loops
		#
		interval="5"
	fi

	unset FLL_BLOCKDEVS FLL_BLOCKDEVS_OLD FLL_MOUNT_LOOP
	
	while [ "${slumber}" -gt 0 ]; do
		#
		# sleep time, we skip slumber interval for first pass for extra fast boot
		#
		if [ "${FLL_MOUNT_LOOP}" ]; then
			if [ "${FLL_MOUNT_LOOP}" = 1 ]; then
				printf "${GREEN}Waiting up to ${YELLOW}${slumber}${GREEN}s for devices to settle...${NORMAL}\n\n"
			fi
			/bin/sleep "${interval}"
			slumber=$(( ${slumber} - ${interval} ))
		fi

		#
		# mount loop counter, it enforces sleep interval on next loop
		#
		if [ -z "${FLL_MOUNT_LOOP}" ]; then
			FLL_MOUNT_LOOP=1
		else
			FLL_MOUNT_LOOP=$(( ${FLL_MOUNT_LOOP} + 1 ))
		fi
		
		#
		# determine block devices to be probed on this loop
		#
		if [ "${FLL_FROMHD_DEV}" ]; then
			#
			# user defined block device
			#
			FLL_BLOCKDEVS="${FLL_FROMHD_DEV}"
		else
			#
			# current list of block devices that may be probed for live media
			#
			FLL_BLOCKDEVS_NOW=$(fll_finger_blockdevs)
			#
			# FLL_BLOCKDEVS_OLD accounts for all devices probed so, it appends a copy of FLL_BLOCKDEVS
			# for every loop
			# FLL_BLOCKDEVS is always a list of devices that have not been probed so far
			#
			if [ "${FLL_BLOCKDEVS_OLD}" ]; then
				#
				# compare all devices probed so far with list of devices discovered now
				#
				for dev in ${FLL_BLOCKDEVS_NOW}; do
					if echo "${FLL_BLOCKDEVS_OLD}" | grep -q "\<${dev}\>"; then
						#
						# we have already probed these devices
						#
						:
					else
						#
						# we have yet to probe these devices
						#
						if [ -z "${FLL_BLOCKDEVS}" ]; then
							FLL_BLOCKDEVS="${dev}"
						else
							FLL_BLOCKDEVS="${FLL_BLOCKDEVS} ${dev}"
						fi
					fi
				done
			else
				#
				# no devices probed so far, probe all that are currently detectable at this time
				#
				FLL_BLOCKDEVS="${FLL_BLOCKDEVS_NOW}"
			fi
		fi
	
		if [ -z "${FLL_BLOCKDEVS}" ]; then
			continue
		fi
		
		printf "${GREEN}Probing devices\t${NORMAL}"
		for dev in ${FLL_BLOCKDEVS}; do
			#
			# FLL_BLOCKMNT		- tracks current mount point
			#
			# FLL_DOUMOUNT		- stack of mount points to be umounted at end of
			#			  loop
			#
			# FLL_DOMOVEMOUNT	- stack of mount points to be move mounted if the
			#			  loop is broken
			#
			# FLL_MEDIA_FOUND	- set only when we have the live media compressed
			#			  filesystem located and mounted
			#
			unset FLL_BLOCKMNT FLL_DOUMOUNT FLL_DOMOVEMOUNT FLL_MEDIA_FOUND
		
			#
			# determine filesystem type of block device
			#
			if fll_finger_fstype "${dev}" >/dev/null 2>&1; then
				printf "${WHITE}[${YELLOW} ${dev#/dev/}${WHITE} ]${NORMAL} "
				#
				# we have determined FSTYPE of the device, set FLL_BLOCKMNT
				#
				FLL_BLOCKMNT="/mnt/${dev#/dev/}"
				mkdir -p "${FLL_BLOCKMNT}"
				#
				# mount block device on FLL_BLOCKMNT for probe
				#
				if fll_mount "${FSTYPE}" "${dev}" "${FLL_BLOCKMNT}" ro; then
					#
					# add current FLL_BLOCKMNT to FLL_DOMOVEMOUNT stack
					#
					FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
					#
					# probe for iso image
					#
					if [ "${FLL_FROMISO}" = "yes" ]; then
						if [ -f "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME}" ]; then
							#
							# located iso, update dev description
							#
							FLL_MEDIA_FOUND="${dev}"
							printf "\n\n"
							printf "${GREEN}Detected ${YELLOW}${FLL_MEDIA_NAME}${GREEN} "
							printf "on ${YELLOW}${FLL_MEDIA_FOUND}${GREEN}.${NORMAL}\n"
							if fll_finger_fstype "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME}" >/dev/null 2>&1; then
								if [ "${FSTYPE}" != "iso9660" ]; then
									panic "${YELLOW}${FLL_MEDIA_NAME}${RED} not an iso9660 filesystem${NORMAL}"
								fi
								mkdir -p /mnt/fromiso
								#
								# loop mount iso on FLL_MEDIA_MOUNTPOINT
								#	
								if fll_mount "${FSTYPE}" "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME}" /mnt/fromiso; then
									if [ "${FLL_TORAM}" ]; then
										#
										# add block device mount point to umount stack
										#
										FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
									fi
									#
									# update FLL_BLOCKMNT, FLL_DOMOVEMOUNT stack, and dev description
									#
									FLL_BLOCKMNT="/mnt/fromiso"
									FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
									dev="iso"
								else
									panic "${RED}Failed to mount ${YELLOW}${FSTYPE}${RED} filesystem from iso image${NORMAL}"
								fi
							else
								panic "${RED}Failed to identify filesystem type of iso${NORMAL}"
							fi
						fi
					fi
					#
					# probe for compressed filesystem
					#
					if [ -f "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" ]; then
						#
						# found FLL compressed filesystem
						#
						if [ "${FLL_MEDIA_FOUND}" ]; then
							printf "\n"
						else
							printf "\n\n"
						fi
						FLL_MEDIA_FOUND="${dev}"
						if fll_finger_fstype "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" >/dev/null 2>&1; then
							printf "${GREEN}Detected live ${YELLOW}${FSTYPE}${GREEN} "
							printf "filesystem on ${YELLOW}${FLL_MEDIA_FOUND}${NORMAL}\n"
							#
							# copy to tmpfs
							#
							if [ "${FLL_TORAM}" ]; then
								#
								# required tmpfs size: compressed filesystem size + 10% buffer
								#
								eval $(fll_meminfo)
								FLL_TORAM_FSSIZE=$(du -s "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" | \
									awk '{ printf("%d\n", int($1 * 1.1 / 1024)) }')
								#
								# memory required to operate normally after iso has consumed memory
								# at least 32M is required
								#
								FLL_TORAM_MEMREQ=$(( ${FLL_TORAM_FSSIZE} + 32 ))
								#
								# do we have enough free memory for toram?
								#
								if [ "${MEMFREE}" -gt "${FLL_TORAM_MEMREQ}" ]; then
									#
									# prepare tmpfs, aka ramdisk
									#
									mkdir -p "/dev/shm/${FLL_IMAGE_DIR}"
									mount -n -t tmpfs -o size="${FLL_TORAM_FSSIZE}m" tmpfs "/dev/shm/${FLL_IMAGE_DIR}"
									#
									# copy compressed filesystem to tmpfs
									#
									printf "${GREEN}Copying live filesystem from ${YELLOW}${dev}${GREEN} "
									printf "to ${YELLOW}ram${GREEN}, please be patient...${NORMAL}"
									if cp "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" "/dev/shm/${FLL_IMAGE_DIR}"; then
										#
										# add old mnt pnt to umount stack, update FLL_BLOCKMNT and dev
										#
										FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
										FLL_BLOCKMNT="/dev/shm"
										dev="ram"
										printf "${GREEN}done${NORMAL}\n"
									else
										if [ "${FLL_FROMISO}" = "yes" ]; then
											#
											# we failed to copy iso contents to ram: reset FLL_DOUMOUNT stack
											#
											unset FLL_DOUMOUNT
										fi
										printf "${RED}failed${NORMAL}\n"
									fi
								else
									printf "${RED}Insufficient free memory to copy live media into memory${NORMAL}\n"
									printf "${RED}Required free memory: ${YELLOW}${FLL_TORAM_MEMREQ}M${NORMAL}\n"
									if [ "${FLL_FROMISO}" = "yes" ]; then
										#
										# we failed to copy iso contents to ram: reset FLL_DOUMOUNT stack
										#
										unset FLL_DOUMOUNT
									fi
								fi
							fi
							#
							# mount compressed filesystem, source directory: FLL_BLOCKMNT
							#
							mkdir -p "${FLL_MOUNTPOINT}"
							if fll_mount "${FSTYPE}" "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" "${FLL_MOUNTPOINT}"; then
								printf "${GREEN}Mounted ${YELLOW}${FSTYPE}${GREEN} filesystem "
								printf "on ${YELLOW}${FLL_MOUNTPOINT}${NORMAL}\n\n"
								FLL_DOMOVEMOUNT="${FLL_MOUNTPOINT} ${FLL_DOMOVEMOUNT}"
							else
								panic "${RED}Failed to mount ${YELLOW}${FSTYPE}${RED} filesystem${NORMAL}"
							fi
						else
							panic "${RED}Failed to identify filesystem type of live media image${NORMAL}"
						fi
					else
						#
						# probe next device, add current mount to FLL_DOUMOUNT stack
						#
						FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
					fi
				fi
			fi
		
			#
			# umount mount points in FLL_DOUMOUNT stack
			#
			for mnt in ${FLL_DOUMOUNT}; do
				umount "${mnt}" && rmdir "${mnt}"
			done
		
			#
			# break upon successful mount of live-media
			#
			if [ "${FLL_MEDIA_FOUND}" ]; then
				break 2
			fi
		done
		
		#
		# keep account of what devices we have probed so far
		#
		if [ "${FLL_BLOCKDEVS_OLD}" ]; then
			FLL_BLOCKDEVS_OLD="${FLL_BLOCKDEVS_OLD} ${FLL_BLOCKDEVS}"
		else
			FLL_BLOCKDEVS_OLD="${FLL_BLOCKDEVS}"
		fi
		
		#
		# clear FLL_BLOCKDEVS list, it is recalculated on next loop
		#
		unset FLL_BLOCKDEVS
	done

	#
	# panic on failure to detect live media
	#
	if [ -z "${FLL_MEDIA_FOUND}" ]; then
		panic "${RED}Failed to detect live media${NORMAL}"
	fi

	#
	# debug checkpoint
	#
	maybe_break fll-postmount

	#
	# mount a tmpfs over $rootmnt, reserving 10% system memory
	# Note: $rootmnt must be mounted with a fs != rootfs prior to run-init
	#
	printf "${GREEN}Mounting virtual memory ${YELLOW}tmpfs${GREEN} filesystem on ${YELLOW}${rootmnt}${GREEN}...${NORMAL}"
	if mount -n -t tmpfs -o size=90%,mode=755 tmpfs "${rootmnt}"; then
		printf "\n"
	else
		panic "${RED}Failed to mount tmpfs over ${YELLOW}${rootmnt}${NORMAL}"
	fi

	#
	# move all mounts in FLL_DOMOVEMOUNT stack to $rootmnt
	#
	if [ "${FLL_DOMOVEMOUNT}" ]; then
		printf "${GREEN}Moving all mounted filesystems to ${YELLOW}${rootmnt}${GREEN}...${NORMAL}"
		for mnt in ${FLL_DOMOVEMOUNT}; do
			if grep -q "${mnt}" /proc/mounts; then
				mkdir -p "${rootmnt}${mnt}"
				mount -n -o move "${mnt}" "${rootmnt}${mnt}"
			fi
		done
		printf "\n"
	fi
	
	#
	# sanity check, ${rootmnt}${FLL_MOUNTPOINT} _must_ exist
	#
	if [ ! -d "${rootmnt}${FLL_MOUNTPOINT}" ]; then
		panic "${RED}Failed to find ${YELLOW}${FLL_MOUNTPOINT}${GREEN} on ${YELLOW}${rootmnt}${NORMAL}"
	fi

	#
	# prepare COW union filesystem
	#
	if [ "${FLL_UNION_MODULE}" ]; then
		FLL_UNION_MOUNTPOINT="/UNIONFS"
		FLL_UNION_COWDIR="/COW"
		mkdir -p "${rootmnt}${FLL_UNION_MOUNTPOINT}" "${rootmnt}${FLL_UNION_COWDIR}"
		#
		# union module specific options
		#
		case "${FLL_UNION_MODULE}" in
			aufs)
				FLL_UNION_OPTIONS="br:${rootmnt}${FLL_UNION_COWDIR}:${rootmnt}${FLL_MOUNTPOINT}"
				;;
			unionfs)
				FLL_UNION_OPTIONS="dirs=${rootmnt}${FLL_UNION_COWDIR}=rw:${rootmnt}${FLL_MOUNTPOINT}=ro"
				;;
		esac
		#
		# mount the union COW filesystem
		#
		printf "${GREEN}Mounting ${YELLOW}${FLL_UNION_MODULE}${GREEN} union filesystem...${NORMAL}"
		if mount -t "${FLL_UNION_MODULE}" -o "${FLL_UNION_OPTIONS}" "${FLL_UNION_MODULE}" "${rootmnt}${FLL_UNION_MOUNTPOINT}"; then
			printf "\n"
		else
			panic "${RED}Failed to prepare ${YELLOW}${FLL_UNION_MODULE}${RED} union filesystem${NORMAL}"
		fi
	else
		#
		# a unionless link farm could be staged here, currently not supported
		#
		panic "${RED}Live mode without union filesystem not supported${NORMAL}"
	fi

	printf "${GREEN}Preparing live filesystem on ${YELLOW}${rootmnt}${GREEN}...${NORMAL}\n"
	
	#
	# create links on $rootmnt to real filesystem
	#
	for dir in ${rootmnt}${FLL_MOUNTPOINT}/*; do
		if [ -d "${dir}" ]; then
			#
			# strip path
			#
			dir="${dir#*/}"
			case "${dir}" in
				dev|media|mnt|proc|sys|tmp)
					#
					# these should stay out of the unioned filesystem mount point
					# keep them directly on the ramdisk, they are handled below
					#
					continue
					;;
				home|root)
					#
					# bind /home and /root to its usual path for cosmetic purposes
					#
					mkdir -p "${rootmnt}/${dir}"
					mount -n -o bind "${rootmnt}${FLL_UNION_MOUNTPOINT}/${dir}" "${rootmnt}/${dir}"
					;;
				*)
					#
					# symlink everything else. note the leading . to anchor the symlink to
					# relative dir, tricks run-init into working with our minor link farm (/sbin/init)
					#
					ln -sf ".${FLL_UNION_MOUNTPOINT}/${dir}" "${rootmnt}/${dir}"
					;;
			esac
		fi
	done

	#
	# prepare /media /mnt /proc /sys
	#
	for dir in media mnt proc sys; do
		if [ ! -e "${rootmnt}/${dir}" ]; then
			mkdir -p "${rootmnt}/${dir}"
		fi
	done

	#
	# tmp with correct permissions for users
	#
	mkdir -p -m 1777 "${rootmnt}/tmp"

	#
	# prepare /dev
	# Note: disable movement of static $rootmnt/dev by scripts/init-bottom/udev
	#
	mkdir -p -m 0755 "${rootmnt}/dev"
	export no_static_dev="1"

	#
	# purge /etc/rc?.d/ for live boot
	#
	for dir in ${rootmnt}/etc/rc*.d; do
		if [ -d "${dir}" ]; then
			rm -rf "${dir}" && mkdir -p "${dir}"
		fi
	done
	
	#
	# link up initscripts-$distro-live
	#
	ln -sf ../init.d/live-autoconfig	"${rootmnt}/etc/rcS.d/S00live-autoconfig"
	ln -sf ../init.d/live-halt		"${rootmnt}/etc/rc0.d/S90live-halt"
	ln -sf ../init.d/live-reboot		"${rootmnt}/etc/rc6.d/S90live-reboot"

	#
	# debug checkpoint
	#
	maybe_break fll-bottom

	printf "\n${GREEN}Starting init process...${NORMAL}\n\n"
}
###############################################################################
